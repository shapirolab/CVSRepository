\documentstyle[twoside,11pt]{report}
\title{Stochastic $\Pi$ Calculus - a Tutorial}
\author{William Silverman \and Aviv Regev}
\date{August 2003}
\begin{document} 
\maketitle

\tableofcontents

\chapter{Introduction}
{\bf $\Pi$ Calculus} is an abstract model of concurrent communication
developed in the late 1980s to express the behavior of mobile systems
\cite{Milner99}.  This document describes an implementation of
{\bf $\Pi$ Calculus} and its stochastic extension in {\bf Flat
Concurrent Prolog} (FCP) \cite{Shapiro87a}.  The implementation is
embedded in {\bf The Logix System} (LOGIX)
\cite{logix:user-man,logix:user-man-supp}. Unlike most previous
implementations ({\em e.g.} Pict \cite{PT99}), we implement the fully
synchronous calculus, where a send and its corresponding receive
are completed simultaneously.  We further extend it to the stochastic
variant (\cite{Pri95},\cite{RPSS}), where communication actions are
assigned rates, and communication events are selected on a
probabilistic basis, rather than a nondeterministic one.  The SPI
system is developed as part of the BioSPI project, whose goal is to
study biomolecular systems as concurrent processes. Therefore, we
adhere closely to the concise Stochastic $\Pi$ Calculus, and only rarely
add functionalities beyond its original core.

The tutorial is constructed as follows: In Chapter \ref{syntax}, we
informally introduce the basic entities and operators of the
$\Pi$ Calculus, and their appropriate representation in SPI syntax. The
full correspondence between the SPI syntax and $\Pi$ Calculus is given in
Appendix \ref{SPIBNF}.  We follow, in Chapter \ref{simple programs}, with
several simple programs, their compilation and execution. Chapter
\ref{stochastic} extends these example to the stochastic variant.  We
then describe, in Chapter \ref{debug}, the available testing,
tracing and debugging tools. Chapter \ref{usingFCP} explains how
LOGIX guard and goal predicates may be used to perform arithmetic
computations and to produce other useful side-effects.  Chapter
\ref{aspic} describes the extension to Ambient Stochastic
$\Pi$ Calculus.

The full set of commands for both systems, is in
Appendix \ref{commands}.

\chapter{Processes, Channels and Communication: The $\Pi$ Calculus in
SPI Syntax}
\label{syntax}

$\Pi$ Calculus describes systems of agents which exist in
parallel. These agents communicate with each other by sending and
receiving messages on channels identified by names. A message may
be a simple signal or a tuple of channel names, which can be used by the
receiving process for further communication. This behavior, which
allows the topology of communication networks to change over time, is
called mobility

\section{Simple Processes}

The basic unit of computation is the Process. The simplest process, 0,
has no observable behavior. To make this into a SPI program, we need
to declare the process, by assigning it a Capitalized name. The LOGIX
language attribute is also required as the first line of a module,
containing a SPI program. We
will omit it in the remaining examples in this chapter.

\begin{verbatim}
  -language(spifcp).
  Try ::= 0 .

\end{verbatim}

Systems are composed of multiple concurrent processes, which are
composed in parallel. The {\em PAR} (\verb+ | +) operator is used for such
composition. Each of the sub-processes must be declared separately.

\begin{verbatim}
  Try ::= Try_again | Try_another .

  Try_again ::= 0 .

  Try_another ::= 0 .
 
\end{verbatim}

\section{Channels and communication}

\subsection{Public Channels}

What processes mostly do is communicate with each other. This is done
on channels, on which processes may send messages to each
other. A Channel is denoted by a name, starting with a lower-case
letter.  There are several kinds of channels. We start with {\em public}
channels; a public channel is common to all the processes in the system
for which it is declared. Public channels are declared for the
processes of a program (file) by a ``public'' attribute at the beginning
of the program.

Processes communicate on channels by sending and receiving
messages. The send action \verb+ x ! [] + denotes a process that
sends a signal, \verb+ [] + on the channel \verb+ x +. This
transmission can be completed when another concurrent process is ready
to receive a signal on the same channel, as for example by the receive
action \verb+ x ? [] +.

When a transmission is completed, the constituent actions of the
sending and receiving processes are no longer available.
The sending and receiving processes are released together -
communication is synchronized.  The following action in each process
may now begin.  A sequence of actions is separated by the {\em comma}
infix operator (\verb+ , +).  The last action in a sequence is
delimited from the continuation of the process by a comma.
The \verb+ 0 + process terminates with no further action.

\begin{verbatim}
  public(x).

  Try ::= Try_again | Try_another .

  Try_again ::= x ! [] , 0 .

  Try_another ::= x ? [] , 0 .
 
\end{verbatim}
 
A signal, or {\em nil} message, is the simplest message; it can be used
for synchronization. Messages with content can be sent as
well.  This content is a tuple of one or more channels, which the
receiver can use for further communications.  For example, in the
following programs, the \verb+ Try_again + process sends the channel
\verb+ z + (by the action \verb+ x ! {z} +) to \verb+ Try_another +,
which  uses channel  \verb+ z + in its communication with
\verb+ Another_try +.  Note, that channel \verb+ w + is not declared;
it is dynamically bound by the receive action.

\begin{verbatim}
  public(x, z).

  Try ::= Try_again | Try_another | Another_try .

  Try_again ::= x ! {z} , 0 .

  Try_another ::= x ? {w} , w ! [] , 0 .

  Another_try ::= z ? [] , 0 .
 
\end{verbatim}

\noindent
Tuples of more than one channel can be sent as messages, {\em e.g.}
\verb+ x ! {z, y, w} +. 

\subsection{Choice}

A process may offer more than one communication.  We have already seen
that several sub-processes, each with a different communication may
be spawned concurrently, using the infix {\em PAR} operator. A
{\em normal} process may offer several mutually exclusive
communications, by using the infix {\em choice} operator (\verb+ ; +).
When one communication is completed, all other offers of that process 
are discarded.
A normal process may be constructed either by the choice operator
between sequences of communication actions, or by the {\em sum}
operator (\verb- + -) from simple normal processes. Having the
syntactic ability to
sum either actions or processes can often simplify programs
considerably, as we shall see in the discussion of recursive processes.
In the following example \verb+ Try_again + is declared using the choice
operator, while \verb+ Try_another + is declared with the sum operator.


\begin{verbatim}
  public(w, x, y, z).

  Try ::= Try_again | Try_another | Another_try .

  Try_again ::= x ! {z} , 0 ;
                y ! {w} , 0 .

  Try_another ::= First_try + Second Try .

  First_try ::= x ? {a} , a ! [] , 0 .

  Second_try ::= y ? {a} , a ! [] , 0 .

  Another_try ::= z ? [] , 0 .
 
\end{verbatim}

\noindent
Note, that \verb+ Try_again + and \verb+ Try_another + can interact
either on channel \verb+ x + or on channel \verb+ y +, with different
outcomes.  In the original calculus this choice is resolved in a
non-deterministic way.  Later we will see how it can be resolved in a
probabilistic way in the stochastic variant.

\subsection{Scopes and Private Channels}

The scope of communication may be restricted to a particular process,
by declaring a new {\em private} channel in a process; the private
channel is known only
within the declaring process and its declared sub-processes, and is
distinguished from any other channel (public or private) with the same
name.  Importantly, the scope of a private channel may be expanded by
sending it to outside processes, an event called {\em scope extrusion}. 
Private channels can be declared during process declaration, using the
\verb- + - operator.  For example, the private channel \verb+ x + is
declared in \verb+ Try_again + below. It is distinct from and cannot 
communicate with the public channel \verb+ x + in \verb+ Another_try +.

\begin{verbatim}
   public(w, x, y, z).

   Try ::= Try_again | Try_some_more | Another_try .

   Try_again + x ::= y ! {x}, ( x ! {w} , 0 ;
                                y ! {z} , 0 ) .

  Another_try ::= x ? [] , 0 .
 
\end{verbatim}

Process scopes may be restricted as well. In this case, a local
process can only be called within the scope in which it was
declared. This process scoping, which is not part of the original
calculus, was added in order to simplify the writing of complex
programs.  A process scope is delimited by the paired brackets
\verb+ << + and \verb+ >> +.  For example, \verb+ First_try + and
\verb+ Second_try + are scoped within \verb+ Try_another + in the
following program; they cannot be referenced in the outer scope.

\begin{verbatim}
  public(x, y, z).

  Try ::= Try_another | Another_try .

  Try_another ::= << 
                     First_try + Second Try .

                     First_try ::= x ? {a} , a ! [] , 0 .

                     Second_try ::= y ? {a} , a ! [] , 0 
                  >> .

  Another_try ::= x ! {z} , z ? [] , 0 .
 
\end{verbatim}

\noindent

Note that the last process within the scope is delimited by \verb+ >> +,
followed by a full stop (\verb+ . +) to end the declaration.  See
Appendix \ref{SPIBNF} for further details.

A delimited process scope can also be used for the declaration of
new channels, without the need of an explicit process declaration.
This possibility is often very convenient. In the next example, the
{\em new} predicate has been subsumed into a prefix
\verb+ <new_declaration_list> +
of a \verb+<new_scope>+, declaring the private channels \verb+ x, y +.

\begin{verbatim}
  Try ::= <<
             x, y . First_try + Second Try |
                    Another_try(x) | Another_try(y) .

             First_try ::= x ? {a} , a ! [] , 0 .

             Second_try ::= y ? {a} , a ! [] , 0 
          >> .

  Another_try(x) + b ::= x ! {b} , b ? [], 0 .
 
\end{verbatim}

\subsection{Comparison}

Sequences of actions may also include comparison actions in
addition to communication actions. This provides an if-then-else construct
based on the comparison of two channels. Similar to communication
actions, comparison actions can be disjuntively chosen, to yield a
case-like construct. Note, that a full if-then else structure is
required, so an otherwise action must be included. More than one pair
of channels may be compared in a single comparison guard. In the following
program, Choose receives a 2-tuple of channels (\verb+ {x1, x2} +)
on channel \verb+ w +, and selects the continuation by matching them
to a pair of channels from \verb+ x, y, z +.

\begin{verbatim}
  public(w, x, y, z).

  Try ::= Choose | First_choice | Second_choice | Third_choice .

  Choose ::= <<
                w ? {x1, x2} , <<
                                  x1 =?= x & x2 =?= y , Choice1 ;
                                  x1 =?= x & x2 =?= z , Choice2 ;
                                  otherwise , Choice3
                               >> .

                Choice1 ::= z ! [] , 0 .

                Choice2 ::= y ! [] , 0 . 

                Choice3 ::= x ! [] , 0
             >> .
  
  First_choice  ::= w ! {x, y}, 0 .
          
  Second_choice ::= w ! {x, z}, 0 .

  Third_choice  ::= w ! {y, z}, 0 .  
 
\end{verbatim}


\section{Parametric and Recursive Processes}

In the original $\Pi$ Calculus, parametric and recursive processes are
derived forms, based on a replication operator ({\bf Bang}).  This operator
provides an unlimited number of concurrent processes, and is therefore
inappropriate for realistic implementations. On the other hand,
parametric and recursive process definitions are extremely useful, and
are therefore primitive in the SPI syntax, in a straightforward way,
as seen in the following example:

\begin{verbatim}
  public(x).

  Try ::= A(x) .

  A(a) ::= a ? {b, c} , B(b, c) .

  B(e, f) ::= e ! {f} , A(f) 
 
\end{verbatim}


\chapter{Getting Started with SPI}
\label{simple programs}

In this chapter we present several programs written in SPI.

\section{Hello}

One thing that a process can do is to to cause an observable
event in the outside world. In our case, this world is LOGIX.
For example, the process Main, in the program below will cause
LOGIX to display the string ``Hello World'' on the screen.

\begin{verbatim}
  Main ::= screen#display("Hello World").
\end{verbatim}

\noindent

The program declares the process \verb+ Main +. In order for it to execute,
it must be run.  To run this program, put it in a file,
{\em e.g.} \verb+ hello.cp +, preceded by the LOGIX attribute:

\begin{verbatim}
  -language(spifcp).
\end{verbatim}

Now enter the {\bf UNIX} command ``\verb+ logix +'',
When the LOGIX prompt ``\verb+ @ +'' appears,
enter the LOGIX command ``\verb+ hello#"Main" +''.  The screen will look
something like this:

\begin{verbatim}
  % logix

  Weizmann Institute Logix 2.2 05/10/00 - 12:56:37
  Copyright (C) 2000, Weizmann Institute of Science - Rehovot, ISRAEL
  Welcome to LINUX Logix !
  05/10/00 - 14:22:35
  @hello#"Main"
  <1> started
  source : /home/tova/hello.cp - 20001005142355
  interpret : export([Main / 0])
  file : /home/tova/hello.bin - written
  Hello World
  <1> terminated
\end{verbatim}

\noindent
LOGIX has found the file \verb+hello.cp+, compiled it using
the language specification, and executed it.  From now on when listing
program output, we will assume that the program has already been
compiled.

\section{Which}

A slightly more complex program is \verb+ which +. In this program we
declare four processes (\verb+ True +, \verb+ False +, \verb+ Send +, and
\verb+ Answer +).  The process \verb+ True +, for example, calls two
sub-processes, \verb+ Send + and \verb+ Answer +, composed in parallel
with the {\em PAR} operator.  Both \verb+ Send + and
\verb+ Answer + are parametric processes. Answer, for instance, is 
called with the channels \verb+ true + and \verb+ false +.  These
channels are private channels, declared in \verb+ True + by
the {\em new} (\verb- + -) operator. Thus, channel true is shared only
by the \verb+ Send + and \verb+ Answer + sub-processes spawned by
\verb+ True +.

\begin{verbatim}
  True + (true, false) ::=
     Send(true) | Answer(true, false) .

  False + (true, false) ::=
     Send(false) | Answer(true, false) .

  Send(it) ::=
     it ! [] , 0 .

  Answer(yes, no) ::=
     yes ? [] , screen#display("Too true!") ;
     no ?  [] , screen#display("Too bad!")  .
\end{verbatim}

The calls to \verb+ True + and \verb+ False + behave differently.
The process \verb+ Answer + receives a {\em nil} signal (\verb+ [] +) on one
of its two channels and displays a corresponding result.

\begin{verbatim}
  @which#"True"
  <1> started
  Too true!
  <1> terminated
  @which#"False"
  <2> started
  Too bad!
  <2> terminated
\end{verbatim}

\noindent
An alternative form of \verb+ which +, using public channels instead
of new channels is \verb+ public_which +. In this case the
\verb+ yes + and \verb+ no + channels are declared by the public
command, and are common to all the instances of \verb+ Send +
and \verb+ Answer +.

\begin{verbatim}
  public(yes, no).

  True ::= Send(yes) | Answer.

  False ::= Send(no) | Answer.

  Send(it) ::= it ! [] , 0 .

  Answer ::=
     yes ? [] , screen#display("Too true!") ;
     no  ? [] , screen#display("Too bad!")  .
\end{verbatim}

\noindent
It has the same behavior as \verb+ which +.

\section{Boolean And}
\label{bland}

A more complex program, \verb+ bland +, performs a boolean {\em AND}
computation.  In this program we make use of the mobility of the
calculus, receiving channels and using them in further
communications. For example, The process \verb+ TT + receives two
channels on channel \verb+ b +, and transmits a signal on the first
of them. Three public channels, \verb+ b1, b2, c +, ensure initial
communication between the constituent sub-processes of each 
\verb+ Run +. Then, the  newly declared channels, \verb+ t, f, x +,
are transmitted and allow additional interaction, {\em e.g.} between
\verb+ TT + and \verb+ Test +.  The ``export'' attribute specifies
which processes may be called externally (If it is omitted, all
outer scope processes may be called.)

\begin{verbatim}
  export(RunTT, RunTF, RunFT, RunFF).
  public(b1, b2, c).

  TT(b) ::= b ? {t,f} , t ! [] , 0 .

  FF(b) ::= b ? {t,f} , f ! [] , 0 .

  Test(b) ::=
     << t, f . b ! {t,f} , 
               ( f ? [] , screen#display("It's false");
                 t ? [] , screen#display("It's true") ) >> .

  AndB ::=
     c ? {t,f} , << x . b1 ! {x,f} , x ? [] , b2 ! {t,f} , 0 >> .

  RunTT ::= Test(c) | AndB | TT(b1) | TT(b2) .

  RunFT ::= Test(c) | AndB | FF(b1) | TT(b2) .

  RunTF ::= Test(c) | AndB | TT(b1) | FF(b2) .

  RunFF ::= Test(c) | AndB | FF(b1) | FF(b2) .
\end{verbatim}

\noindent
The paired brackets ``\verb+<<+'' and ``\verb+>>+'' declare
a nested scope in which channels may be declared, and an
un-named process is defined and executed.

\noindent
Try compiling \verb+ bland + and calling the exported processes.
Note that \verb+ RunFT + and \verb+ RunFF + do not terminate.  You
can inspect the state of a computation by entering the SPI macro command
``spr'' following the LOGIX prompt.

\begin{verbatim}
  @bland#"RunFF"
  <1> started
  It's false
  @spr
  <1> suspended
  bland # AndB.1.1.comm(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
  bland # FF.comm(public.b2!)
\end{verbatim}

\noindent
The two line resolvent of the computation says that a nested sub-process of
\verb+ AndB + (using channels \verb+ t, f, b2, x +) and the process
\verb+ FF + (using channel \verb+ b2 +) are both waiting to communicate.
By inspection of the program, we see that the action ``\verb+ x ? [] +''
of \verb+ AndB + is waiting to receive a signal, \verb+ [] +, and the
action ``\verb+ b ? {t,f} +'' of \verb+ FF + is waiting to receive a
2-tuple of channels.  The enhanced channel names indicate the clauses
which created them.  The suffix exclamation points (\verb+ ! +),
indicate which channels are active (offering a send or receive).

\section{Modular Boolean And}
\label{mbland}
Another way to write the program \verb+ bland + is to divide it
into separate modules. If a sub-process from a different module is
needed by a process, we use the module name in the command, {\em e.g.}
\verb+ boolean#TT(b1) + in the \verb+ RunFT + process.

\begin{verbatim}
                              band.cp

  -language(spifcp).

  public(b1,b2,c).

  AndB ::= c?{t,f} , << x . b1!{x,f} , x?[] , b2!{t,f}, 0 >> .
\end{verbatim}

\begin{verbatim}
                              bnot.cp

  -language(spifcp).

  public(b,c).

  NotB ::= c?{t,f} , b!{f,t} , 0 .

                              boolean.cp
\end{verbatim}

\begin{verbatim}
  -language(spifcp).

  TT(b) ::= b?{t,f}, t![], 0.

  FF(b) ::= b?{t,f}, f![], 0.
\end{verbatim}

{\samepage
\begin{verbatim}
                              btest.cp

  -language(spifcp).

  public(c).

  Test+(t,f) ::= c!{t,f},
                  <<
                     f?[] , screen#display("It's false") ;
                     t?[] , screen#display("It's true")
                  >>
  .
\end{verbatim}
}

{\samepage
\begin{verbatim}
                            tnot.cp

  -language(spifcp).

  public(b).

  RunT ::= btest#Test | boolean#TT(b) | bnot#NotB .

  RunF ::= btest#Test | boolean#FF(b) | bnot#NotB .
\end{verbatim}
}

\begin{verbatim}
                             tand.cp

  -language(spifcp).

  public(b1,b2).

  RunTT ::= boolean#TT(b1) | boolean#TT(b2) |
            btest#Test | band#AndB .

  RunFT ::= boolean#TT(b1) | boolean#FF(b2) |
            btest#Test | band#AndB .

  RunTF ::= boolean#FF(b1) | boolean#TT(b2) |
            btest#Test | band#AndB .

  RunFF ::= boolean#FF(b1) | boolean#FF(b2) |
            btest#Test | band#AndB .
\end{verbatim}

\noindent
This makes it easy to add boolean not (\verb+ blnot.cp +) and other
boolean functions, modularly.  The modules may be compiled separately
({\em e.g.} by LOGIX command ``\verb+ compile(band) +'') or by calling
an initial process, causing compilation of all modules recursively
required by the computation 
({\em e.g.} LOGIX command ``\verb+ tand#"RunTF" +'').

\chapter{Stochastic Programs}
\label{stochastic}

\section{Stochastic $\Pi$ Calculus}

In all of the programs in the preceding chapters communication on
channels was completed as soon as possible. Furthermore, the choice of
the next communication event to occur was non-deterministic.  In this
chapter we present the stochastic variant, in which communications are
assigned different rates. Based on these rates, weighted, random
delays are calculated, and used to select a complementary pair of
actions to complete and the amount to advance an internal clock.
The stochastic version \cite{Pri95},has been modified and implemented
by us specifically for biochemical reactions \cite{RPSS}.

We distinguish several channel types. Each type corresponds to a
different kind of communication or reaction.  A {\em bimolecular}
channel represents a chemical reaction involving two different
molecules. Upon declaration (as a public or private channel) it is
assigned a non-negative base-rate, which represent the base rate of
the reaction. A {\em homodimerized} channel represents a chemical reaction
involving two molecules of the same kind. It is also assigned a
non-negative base rate. It is distinguished however by its use as both
an input channel and an output channel in the same choice construct,
and cannot be used in any other kind of construct. Finally
{\em instantaneous} channels do not represent actual reactions, but are
rather used for encoding purposes.  They are declared with the rate
``\verb+infinite+''.

When a stochastic program is run, an actual rate is calculated for
each stochastic channel (reaction) based on its base rate and the
number of processes offering to transmit on the channel.  A
communication offer may be modified optionally by an integer mutiplier,
adjusting its weight in the calculation; the default mutiplier is 1.

\par
\label{default rate}
\noindent
For a {\em bimolecular} channel the default actual rate is:

\[ \verb+baserate+ \times \sum(\verb+receive multipliers+) \times
\sum(\verb+send multipliers+) \] 

\noindent
For a {\em homodimerized} channel the default actual rate is:

\[ \frac{\verb+baserate+ \times \sum(\verb+multipliers+) \times
(\sum(\verb+multipliers+) - 1)}{2} \]

Using these actual rates, the next time step and the next
communication are selected, by a standard algorithm \cite{Gil77}.

The default actual rate may be computed by a custom computation,
by specifying an explicit computation function (\verb+<weighter>+).

\section{Simple stochastic programs}
 
Interesting programs submitted by users will be added here.
\newline

\noindent
Meanwhile, see the programs in sub-directory Spi-release/Examples
and in Spi-release/BioSpi/Examples.

\chapter{Testing, Tracing and Debugging}
\label{debug}

LOGIX supports {\em computations}.  A computation is initiated by
a remote procedure call (RPC).  We saw some examples of this in
previous sections.  In general, an RPC has the form:

\begin{verbatim}
   LogixPath#LogixGoal
\end{verbatim}

\noindent
LogixPath may be the name of a module or a transformation of a UNIX path:

\[dir_{1}/dir_{2}/ \cdots /dir_{n}/module.cp  \Rightarrow  dir_{1}\#dir_{2}\# \cdots \#dir_{n}\#module\]

\noindent
where $dir_{1}$ is a directory which is an immediate sub-directory
of the current directory, the current directory itself, or a directory
which contains the current directory.
Since LOGIX treats an alphanumeric name which begins with a lower-case
letter as a string, such directory names need not be quoted - all
other names, which are not the names of LOGIX variables (alphanumeric,
beginning with an upper-case letter or underscore), should be quoted -
{\em e.g.} a pathologically complicated example:

\begin{verbatim}
  tests#"Cases"#"#13"#sub_cases#Module#"TestIt"
\end{verbatim}

\noindent
The terms \verb+ tests +, \verb+ "Cases" +, \verb+ "#13" + and
\verb+ sub_cases + are the names of unix directories along the
path to the process  \verb+ "TestIt" +;
\verb+Module + is a LOGIX variable which should be instantiated to a
module name.

\noindent
LogixGoal may be any atom, referring to a process which is exported by
the target module.  Since a SPI process (here, TestIt) has an
alpha-numeric name
beginning with an upper-case letter, its name must be quoted.

\section{Interruption and Inspection}

An SPI program may reach an impasse ({\em e.g.} \verb+ bland#"RunFF" +
above), reach a limit (see \ref{runners} and \ref{recorders}), be interrupted
manually (see \ref{suspend}) or terminate normally.  At an impasse,
limit or interruption, the current state of the
computation can be inspected by the command ``spr'' (see \ref{spr}),
and the communicating channel set can be inspected by the command ``cta''
(see \ref{cta}).

\section{Debugging}
\label{debugger}

A computation may be run under control of a debugger.

\begin{verbatim}
  pdb(RPC)
\end{verbatim}

\noindent
The computation may be traced, interrupted at break points and
inspected.  Here are some simple examples using the module bland -
see Section \ref{bland}.

\subsection{Trace a Computation}
\label{debug trace}

Following a \verb+ query -> + prompt, enter the command \verb+ trace +.

\begin{verbatim}
  @pdb(bland#"RunTF")
  <1> started
  bland  Debug Reduction Started
  bland  RunTF :- ?
  query -> trace
  bland  RunTF :- 
          .RunTF.
  bland  .RunTF(public.b1, public.b2, public.c) :- 
          Test, AndB, TT, FF.
  bland  Test(public.c!) :- 
          Test.1(public.c!).
  bland  AndB(public.b1!, public.b2!, public.c!) :- 
          AndB.comm(public.b1!, public.b2!, public.c!).
  bland  TT(public.b1!) :- 
          TT.comm(public.b1!).
  bland  FF(public.b2!) :- 
          FF.comm(public.b2!).
  bland  Test.1(public.c!) :- 
          Test.1.(public.c!, Test.1.f, Test.1.t).
  bland  Test.1.(public.c, Test.1.f, Test.1.t) :- 
          Test.1.comm(public.c, Test.1.f, Test.1.t).
  bland  Test.1.comm(public.c, Test.1.f, Test.1.t) :- 
          Test.1.1(Test.1.f, Test.1.t).
  bland  AndB.comm(public.b1!, public.b2!, public.c) :- 
          AndB.1(Test.1.t, Test.1.f, public.b1!, public.b2!).
  bland  Test.1.1(Test.1.f!, Test.1.t!) :- 
          Test.1.1.comm(Test.1.f!, Test.1.t!).
  bland  AndB.1(Test.1.t!, Test.1.f!, public.b1!, public.b2!) :- 
          AndB.1.(Test.1.t!, Test.1.f!, public.b1!, public.b2!,
                   AndB.1.x).
  bland  AndB.1.(Test.1.t!, Test.1.f!, public.b1, public.b2!,
                 AndB.1.x) :- 
          AndB.1.comm(Test.1.t!, Test.1.f!, public.b1, public.b2!,
                      AndB.1.x).
  bland  TT.comm(public.b1) :- 
          TT.1(AndB.1.x).
  bland  AndB.1.comm(Test.1.t!, Test.1.f!, public.b1, public.b2!,
                     AndB.1.x) :- 
          AndB.1.1(Test.1.t!, Test.1.f!, public.b2!, AndB.1.x).
  bland  TT.1(AndB.1.x) :- 
          TT.1.comm(AndB.1.x).
  bland  AndB.1.1(Test.1.t!, Test.1.f!, public.b2!, AndB.1.x) :- 
          AndB.1.1.comm(Test.1.t!, Test.1.f!, public.b2!, AndB.1.x).
  bland  TT.1.comm(AndB.1.x).
  bland  AndB.1.1.comm(Test.1.t!, Test.1.f!, public.b2!, [AndB.1.x]) :- 
          AndB.1.1.1(Test.1.t!, Test.1.f!, public.b2!).
  bland  AndB.1.1.1(Test.1.t!, Test.1.f!, public.b2) :- 
          AndB.1.1.1.comm(Test.1.t!, Test.1.f!, public.b2).
  bland  FF.comm(public.b2) :- 
          FF.1(Test.1.f!).
  bland  AndB.1.1.1.comm(Test.1.t!, Test.1.f!, public.b2).
  bland  FF.1(Test.1.f) :- 
          FF.1.comm(Test.1.f).
  bland  Test.1.1.comm([Test.1.f], [Test.1.t]) :- 
          screen # display(It's false).
  bland  FF.1.comm([Test.1.f]).
  It's false
  bland  Debug Reduction Terminated
  <1> terminated
  @
\end{verbatim}

\noindent
Each traced reduction above has the form;

\begin{verbatim}
  bland  <process name>(<channels>) :-
         <derived goals>
\end{verbatim}

\noindent
Channels which are annotated with a suffix exclamation are
active at the time at which the reduction is displayed\footnote{
The debugger displays the reductions after they have occured,
but not synchronized with the reduction itself.}.

\noindent
Channels which are diplayed within square brackets have been
closed, and are no longer available for communication\footnote{
However, the channel may have been open at the time that the
process was reduced.}.

\noindent
The suffixes following many process names, indicate a derived
sub-process, which may result from prefix guards or from new
scope declarations.  Where the suffix ends in ``.comm'', the
sub-process is one which completes a communication.

\noindent
Where a process is reduced to multiple parallel prcesses, they
are separted by commas, instead of PARs.

\subsection{Interrupt and Inspect a Computation}

Following a \verb+ query -> + prompt, enter a \verb+ break + command.
Following the next \verb+ query -> + prompt, press \verb+ <enter> +.

\begin{verbatim}
  @pdb(bland#"RunFT")
  <1> started
  bland  Debug Reduction Started
  bland RunFT :- ?
  query -> break("AndB")
  bland RunFT :- ?
  query -> 
  bland AndB(public.b1!, public.b2!, public.c!) :- 
         AndB.comm(public.b1!, public.b2!, public.c!).
  query -> 
\end{verbatim}

\noindent
When the computation reaches the specified process, the
debugger prompts \verb+ query -> +;
entering \verb+ debug +, brings the debugger
to inspection mode.

\noindent
Following the \verb+ debug? -> + prompt, entering
\verb+ resolvent +, produces a list
of goals which have not yet been reduced.

\noindent
Entering \verb+ resume + turns off suspension;
entering \verb+ query +, returns to execution
mode, where pressing \verb+ <enter> + continues the computation.

\begin{verbatim}
  query -> debug
  @debug? -> resolvent
  bland  Debug Reduction Suspended
  bland goal - 1 Test.1.1.comm(Test.1.f!, Test.1.t!)
  bland goal - 2 AndB(public.b1!, public.b2!, public.c)
  bland goal - 3 FF.comm(public.b1!)
  bland goal - 4 TT.comm(public.b2!)
  @debug? -> resume
  bland  Debug Reduction Resumed
  @debug? -> query
  bland AndB(public.b1!, public.b2!, public.c!) :- 
         AndB.comm(public.b1!, public.b2!, public.c!).
  query -> 
  It's false
  @debug ->
\end{verbatim}

\noindent
If the computation spontaneously enter's inspection mode,
no active processes remain; the residual processes may
be inspected.

\begin{verbatim}
  @debug -> resolvent
  bland  Debug Reduction Suspended
  bland goal - 1 AndB.1.1.comm(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
  bland goal - 2 TT.comm(public.b2!)
  @debug ->
\end{verbatim}

\noindent
To terminate the computation and the debugging session,
enter \verb+ abort +.

\begin{verbatim}
  @debug -> abort
  bland  Debug Reduction Aborted
  <1> terminated
  @
\end{verbatim}

\section{Tree trace}
\label{vtree traces}

A computation tree may be produced, using the \verb+ vtree +
command - see Section \ref{bland}.

\begin{verbatim}
  @vtree(bland,"RunFT",Tree)
  <1> started
  It's false
\end{verbatim}

\noindent
When the LOGIX prompt appears,
the \verb+ ctree + command closes the tree, terminating
all further construction.

\noindent
\verb+ptree(Tree) + prints the tree in prefix order.

\begin{verbatim}
  @ctree(Tree)
  @ptree(Tree)
  begin : bland # RunFT
   | RunFT
    | .RunFT(public.b1, public.b2!, public.c)
     | Test(public.c)
     | AndB(public.b1, public.b2!, public.c)
     | FF(public.b1)
     | TT(public.b2!)
      ? TT.comm(public.b2!)
      | FF.comm(public.b1)
       | FF.1(Test.1.f)
        | FF.1.comm(Test.1.f)
      | AndB.comm(public.b1, public.b2!, public.c)
       | AndB.1(Test.1.t, Test.1.f, public.b1, public.b2!)
        | AndB.1.(Test.1.t, Test.1.f, public.b1, public.b2!, AndB.1.x!)
         | AndB.1.comm(Test.1.t, Test.1.f, public.b1, public.b2!, AndB.1.x!)
          | AndB.1.1(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
           ? AndB.1.1.comm(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
      | Test.1(public.c)
       | Test.1.(public.c, Test.1.f, Test.1.t)
        | Test.1.comm(public.c, Test.1.f, Test.1.t)
         | Test.1.1(Test.1.f, Test.1.t)
          | Test.1.1.comm(Test.1.f, Test.1.t)
           # screen # display(It's false)
  end : bland # RunFT
  @a
  <1> aborted
  @
\end{verbatim}

\noindent
The meaning of the suffixes and annotation is the same as for
debugging in Section \ref{debug trace}.

\noindent
Indentation illustrates the depth of call within a module.
The prefix ``$|$'' indicates a reduced goal; the prefix
``\#'' indicates a remote process call; the prefix,
``?''  indicates a goal which has not been reduced.  The
prefixes ``begin :'' and ``end :'' delimit a remote process
call.

\noindent
To trace tand (see Section \ref{mbland}) call, {\em e.g.}

\begin{verbatim}
  @vtree(boolean#tand,"RunFT",Tree, 2)
\end{verbatim}

\chapter{Using FCP in SPI modules}
\label{usingFCP}

This chapter describes the use of FCP guards, goals and
variables inside SPI processes.

\section{LOGIX Variables as Counters and Limits}
The following process sends {\bf N} {\em nil} messages to channel {\bf c}.

\begin{verbatim}

  Send(N, c) + I ::= {I = 0} | SendAndCount.

  SendAndCount(I, N, c) ::=
      {I++ < N}, SendNil(c) | self;
      {I >= N }, screen#display(sent - I*[])
  .

  SendNil(c) ::= c ! [], 0.
\end{verbatim}

\noindent
A process argument may be a LOGIX variable - in this case, ``N''.
Such a variable may be passed to another process, or it may be
tested or operated upon in a LOGIX guard or a LOGIX goal.

\noindent
Similarly, a LOGIX variable may be declared in an added argument
list or in a declaration list, or it may be sent or
received in a message - in this example, ``I'' is declared
as an added argument.

\noindent
The LOGIX goal \verb+ {I = 0} + presets I to 0.
\noindent
The LOGIX guards test I, comparing it to N.
The LOGIX guard \verb# {I++ < N} # also increments I, for the
recursive call, self, to the process SendAndCount.

\noindent
The first process may be rewritten:

\begin{verbatim}
  Send(N, c) + I ::= {(true : I = 0)} , SendAndCount.
\end{verbatim}

\noindent
to wait until N is known to be a number, before initializing
I and then continuing with SendAndCount.  This might be useful
if the reactions enabled by SendAndCount should not occur
until N has been initialized, for instance if SendAndCount
were to enable the reactions, and subsequently count them.
\newline

\noindent
Many other LOGIX guards and goals may be employed in SPI processes -
see \cite{logix:user-man} Appendix 1.

\chapter{Ambient Stochastic Programs}
\label{aspic}

Stochastic $\Pi$ Calculus supports a flat process space.  Ambient
Stochastic $\Pi$ Calculus supports nested process spaces,
organized in a tree, and
communication between nearby nodes (called {\em ambients}) of the tree.

\section{Channels}

In addition to a type, a channel in Ambient Stochastic $\Pi$ Calculus
has a {\em locus} as well.  The
locus determines whether communication is {\em local} (within the ambient)
or {\em non-local} (between nearby ambients).  Possible non-local loci of
communication are: Parent to Child, Child to Parent, Sibling to
Sibling.

\section{Ambient Declaration}

Ambients are declared dynamically.
An ambient is declared as a named \verb+<new_scope>+, {\em e.g.}

\begin{verbatim}
  ACell ::= cell(<< x, y. Cytoplasm(x,y) | Membrane(x,y) >>) .
\end{verbatim}

The new ambient is created as a child of the ambient which declares it.
It inherits copies of all of the local channels known to its parent.
When it is created the ambient is assigned a unique positive integer
as part of its identifier ({\em e.g.} cell(17)), which may be used
to distinguish it from other ambients with the same name.

Ambients are mobile. An ambient may
exit its parent, enter a sibling (become its child) or merge with a
sibling.

\section{Ambient Stochastic $\Pi$ Calculus Processes}

The first line of an Ambient Stochastic $\Pi$ Calculus module must be:

\begin{verse}
   -language(biospi).
\end{verse}

\noindent
Any Stochastic $\Pi$ Calculus module may be converted to an
Ambient Stochastic $\Pi$ Calculus module by
replacing the language name in the first line.  The semantics
of the program are unchanged.

\subsection{Inter-Ambient Communication}

A \verb+<send>+ or \verb+<receive>+ may be prefixed by a
\verb+<direction>+, specifying the locus of communication.
The communication is between ambients.  The two communicating
processes do so on their shared channel.

\begin{verbatim}
  direction    kind of communication

  local        intra-ambient (may be omitted)
  p2c          parent to child
  c2p          child to parent
  s2s          sibling to sibling
\end{verbatim}

\noindent
Examples:

\begin{verbatim}
  p2c a ! 3*[]
  s2s b ? {x,y}
\end{verbatim}

\subsection{Capability Communication}

A communication may be an assertion of the form \verb+<capability> <channel>+.
The communication is between ambients.  The two
processes which communicate do so on the shared channel.

\newpage
\begin{verbatim}
  capability   action

  enter        enter a sibling which asserts
                       accept  <channel>
  accept       accept as a child a sibling which asserts
                       enter   <channel>
  exit         become a sibling of its parent which asserts
                       expel   <channel>
  expel        expel a child which asserts
                       exit    <channel>
  merge -      merge with a sibling which asserts
                       merge + <channel>'
  merge +      merge with a sibling which asserts
                       merge - <channel>
\end{verbatim}

\noindent
Examples:

\begin{verbatim}
  enter a
  expel b
  merge - c
\end{verbatim}

\section{Testing Ambient Programs}

Unlike SPI programs, BIOSPI programs cannot be
executed directly under LOGIX.  However, the commands {\em run} (see
\ref{runners}) and {\em record} (see \ref{recorders})
provide means to execute BIOSPI programs.

\section{Interruption and Inspection}

A Ambient Stochastic $\Pi$ Calculus program may reach an impasse ({\em e.g.}
\verb+ bland#"RunFF" + above), reach a limit (see \ref{runners}
and \ref{recorders}), be interrupted manually (see \ref{suspend})
or terminate normally.  At an impasse, limit or interruption,
the current state of the computation can be inspected by the command
{\em rtr} (see \ref{rtr}).
At an impasse, limit or interruption, the tree of ambients can be inspected
by the command {\em atr}; the tree including the communicating channel
set of each ambient can be inspected by the command {\em ctr}
(see \ref{xtr}).

\appendix
\chapter{Syntax and Semantics}
\section{BNF for Stochastic $\Pi$ Calculus}
\label{SPIBNF}
A Stochastic $\Pi$ Calculus module begins with the line:

\begin{verbatim}
-language(spifcp).
\end{verbatim}

\noindent
That line is followed by one \verb+<program>+.

\begin{verbatim}
<program>              ::= <attributes> . <process_definitions> .
                           <process_definitions> .

<attributes>           ::= <attribute>
                           <attribute> . <attributes>

<attribute>            ::= <export_declaration>
                           <public_declaration>
                           <default_baserate_declaration>
                           <default_weighter_declaration>

<export_declaration>   ::= export(<process_name_list>)

<public_declaration>   ::= public(<parameter_list>)

<default_baserate_declaration>
                       ::= baserate(<base_rate>)

<default_weighter_declaration>
                       ::= weighter(<weighter_declaration>)

<process_name_list>    ::= <process_name>
                           <process_name> , <process_name_list>

<weighter_declaration> ::= <weighter>
                           <weighter>(<weighter_parameter_list>)

<weighter_parameter_list>
                       ::= <weighter_parameter>
                           <weighter_parameter> , <weighter_parameter_list>

<parameter_list>       ::= <parameter>
                           <parameter> , <parameter_list>

<parameter>            ::= <channel_declaration>
                           <logix_variable>

<channel_declaration>  ::= <channel>
                           <channel>(<base_rate>)
                           <channel>(<base_rate> , <weighter_declaration>)

<base_rate>            ::= <number>
                           infinite

<process_definitions>  ::= <process>
                           <process> . <process_definitions>

<process>              ::= <left_hand_side> ::= <right_hand_side>

<left_hand_side>       ::= <atom>
                           <atom>+<parameter>
                           <atom>+(<parameter_list>)

<atom>                 ::= <process_name>
                           <process_name>(<parameter_list>)

<right_hand_side>      ::= <communication_clauses>
                           <comparison_clauses>
                           <logix_guard_clauses>
                           <body>

<communication_clauses> ::= 
                           <communication_clause> 
                           <communication_clause> ; <communication_clauses>

<communication_clause> ::= <communication> , <right_hand_side>

<communication>        ::= <receive>
                           <send>

<receive>              ::= <channel> ? <transmission>

<send>                 ::= <channel> ! <transmission>

<transmission>         ::= <message>
                           <multiplier> * <message>
                           <message> * <multiplier>

<message>              ::= []
                           {<parameter_list>}

<multiplier>           ::= <positive_integer>

<comparison_clauses>   ::= <comparisons>
                           <comparisons> ; otherwise , <right_hand_side>

<comparisons>          ::= <comparison_clause>
                           <comparison_clause> ; <comparisons>

<comparison_clause>    ::= <comparison> , <right_hand_side>

<comparison>           ::= <compare>
                           <compare> & <comparison>

<compare>              ::= <channel> =?= <channel>
                           <channel> =\= <channel>

<logix_guard_clauses>  ::= <logix_guard_clause> 
                           <logix_guard_clause> ; <logix_guard_clauses>

<logix_guard_clause>   ::= {<logix_ask_guard>} , <right_hand_side>
                           {(<logix_guard>)} , <right_hand_side>

<logix_guard>          ::= <logix_ask_list>
                           <logix_ask_list> : <logix_tell_list>

<logix_ask_list>       ::= <logix_ask_guard>
                           <logix_ask_guard> , <logix_ask_list>

<logix_tell_list> ::=      <logix_tell_guard>
                           <logix_tell_guard> , <logix_tell_list>

<body>                 ::= <call>
                           <call> | <body>

<call>                 ::= <local_call>
                           <local_call_sum>
                           <nested_scope>
                           <external_call>
                           <macro_call>
                           {<logix_goal>}
                           {(<logix_goal_list>)}
                           true
                           0

<local_call_sum>       ::= <local_call> + <local_sum>

<local_sum>            ::= <local_call>
                           <local_call> + <local_sum>

<local_call>           ::= <local_process_name>
                           <local_process_name>( <argument_list> )

<local_process_name>   ::= <process_name>
                           self

<argument_list>        ::= <parameter_list>
                           <substitution_list>

<substitution_list>    ::= <substitution>
                           <substitution> , <substitution_list>

<substitution>         ::= <channel> = <channel>
                       ::= <logix_variable> = <logix_variable>

<new_scope>            ::= <parameter_list> . <scope_content>
                           <scope_content>

<scope_content>        ::= <right_hand_side>
                           <right_hand_side> . <process_definitions>

<external_call>        ::= <logix_path_term>#<atom>
                           <logix_path_term>#<logix_goal>
                           <logix_path_term>#<external_call>

<macro_call>           ::= set_base_rate(<base_rate>, <channels_reply>)
                           randomize_messages(<channels_reply>)
                           serialize_messages(<channels_reply>)
                           get_channel_status(<channel> , <channel_attributes>)

<channels_reply>       ::= <reply>
                           <channel> , <channels_reply>

<channels_attributes>  ::= <reply>
                           <channel_attribute> , <channel_attributes>

<reply>                ::= <logix_variable>

<logix_goal_list>      ::= <logix_goal>
                           <logix_goal> , <logix_goal_list>
\end{verbatim}

\newpage
\section{Alternate BNF for Ambient Stochatic $\Pi$ Calculus}
\label{ASPICBNF}
An Ambient Stochastic $\Pi$ Calculus module begins with the line:

\begin{verbatim}
-language(biospi).
\end{verbatim}

\noindent
That line is followed by one \verb+<program>+.  The program
has alternative definitions as follows.

\begin{verbatim}
<communication>        ::= <receive>
                           <send>
                           <capability>

<receive>              ::= <channel> ? <transmission>
                           <direction><channel> ? <transmission>

<send>                 ::= <channel> ! <transmission>
                           <direction><channel> ! <transmission>

<direction>            ::= local
                           p2c
                           c2p
                           s2s

<capability>           ::= enter <channel>
                           accept <channel>
                           exit <channel>
                           expel <channel>
                           merge - <channel>
                           merge + <channel>

<call>                 ::= <local_call>
                           <local_call_sum>
                           <external_call>
                           <ambient>
                           <macro_call>
                           {<logix_goal>}
                           {(<logix_goal_list>)}
                           true
                           0

<ambient>              ::= <ambient_name>(<nested_scope>)
\end{verbatim}

\section{Primitives}

\begin{itemize}
\item
\verb+<process_name>+ is an alpha-numeric string, beginning with an
upper-case letter, which may contain underscore (\_) characters.

\item
\verb+<channel>+ is an alpha-numeric string, beginning with a lower-case
alphabetic character; the string may contain underscore (\_) characters.
It represents a $\Pi$ Calculus channel.

\item
\verb+<weighter>+ is an alpha-numeric string, beginning with a lower-case
alphabetic character; the string may contain underscore (\_)
characters.  The currently acceptable values of \verb+<weighter>+ are
``default'' and ``michaelis''; additional values may be defined - see
weighter.txt

\verb+<ambient_name>+ is an alpha-numeric string, beginning with
a lower-case alphabetic character; the string may contain
underscore (\_) characters.
\end{itemize}

\section{Semantics}

A Stochastic $\Pi$ Calculus \verb+<program>+ is completely
equivalent to an Ambient Stochastic $\Pi$ Calculus
\verb+<program>+ with the same content.
 
\begin{itemize}
\item
A \verb+<parameter>+ in a \verb+<public_declaration>+ is an implicit
argument of every process in the program.

\item
Any argument of a \verb+<process>+ may be  provided by a caller in an
\verb+<argument_list>+, replacing any implicit argument of the same
name. 
An argument  may be {\em extruded} from a \verb+<process>+ by a
\verb+<send>+.  An argument
may also be replaced in a \verb+<parameter>+ which is added to the
\verb+<atom>+ in the \verb+<left_hand_side>+ of a
\verb+<process_declaration>+.

\item
A \verb+<base_rate>+ may be specified by a \verb+<logix_variable>+
in the \linebreak
\verb+<default_baserate_declaration>+ or in a
\verb+<channel_declaration>+.  In the former case, or when the
\verb+<channel_declaration>+ is within the \verb+<public_declaration>+,
the \verb+<logix_variable>+ itself must be declared in the
\verb+<public_declaration>+; in the latter case, when the channel
is in the \verb+<parameter>+ which is added in the \linebreak
\verb+<process_declaration>+, the \verb+<logix_variable>+ should
be an argument of the process.  In any case, the \verb+<logix_variable>+
should be instantiated to a non-negative number.

\item
A \verb+<weighter>+ may be specified by a \verb+<logix variable>+
in the \linebreak \verb+<default_weighter_declaration>+ or in a
\verb+<channel_declaration>+.  In the former case, or when the
\verb+<channel_declaration>+ is within the \verb+<public_declaration>+, 
the \verb+<logix_variable>+ itself must be declared in the
\verb+<public_declaration>+; in the latter case, when the channel is in
a \verb+<parameter>+ which is added in the 
\linebreak \verb+<process_declaration>+, 
the \verb+<logix_variable>+ should be an argument of the process.
In any case the \verb+<logix_variable>+ should be instantiated to
a string (see above).

\noindent
A \verb+<weighter_parameter>+ may be specified by a
\verb+<logix_variable>+, as for a \verb+<base_rate>+ (see above).

\item
An argument in a \verb+<macro_call>+ which precedes the \linebreak
\verb+<channels_and_reply>+ or which is a \verb+<channel_attribute>+
may be a read-only-variable
(\verb+<logix_variable>?+).
The \verb+<logix_variable>+ must be instantiated before the
\verb+<macro_call>+ can be completed.

\noindent
When a \verb+<macro_call>+ is completed, the trailing \linebreak
\verb+<logix_variable>+ is instantiated - its value is usually the
string ``true'', but it may vary in some cases.

\noindent
The program macro \verb+get_channel_status+
instantiates the trailing \linebreak
\verb+<logix_variable>+ to the value(s) of the named attribute(s).  See 
\verb+program_macros.txt+ for details regarding
\verb+<channel_attribute>+ \linebreak values.

\noindent
WARNING: When the single underscore character \verb+<logix_variable>+
\linebreak (\_) appears
in a \verb+<receive> <transmission>+ in place of a \linebreak
\verb+<channel>+, the corresponding \verb+<send> <channel>+
should be declared in a \verb+<public_declaration>+.
\end{itemize}

\section{Logix Terms}
See \verb+supplement.mss + for details of the Logix language.

\begin{itemize}
\item
\verb+<logix_ask_guard>+ is any predicate permitted in the ask of a
guard in LOGIX language(compound).

\item
\verb+<logix_tell_guard>+ is any predicate permitted in the tell of a
guard in LOGIX language(compound).

\item
\verb+<logix_goal>+ is any predicate permitted in the right-hand-side
of a clause in LOGIX language(compound).

\item
\verb+<logix_path_term>+ is any term permitted in the path
specification of a remote procedure call in LOGIX language(compound).
\end{itemize}

\section{Notes}

\begin{itemize}

\item
The {\em new} predicate of $\Pi$ Calulus has been subsumed into a prefix
\verb+<parameter_list>+ of a \verb+<new_scope>+
and the added \verb+<parameter_list>+ \linebreak of a \verb+<process>+.

\item
A \verb+<process>+ which is declared at level one of a
\verb+<program>+ definition, may be called by an external process,
if it is exported explicitly in an \verb+<export_declaration>+,
or if there is no \verb+<export_declaration>+ \linebreak in the
\verb+<program>+,
in which case all level one processes are exported.

\item
Nested  ``new'' processes are scoped with double angle brackets (see
definition of \verb+<nested_scope>+).

\item
Each \verb+<local_call>+ in a \verb+<local_call_sum>+ must be
to a \verb+<process>+ \linebreak
whose \verb+<right_hand_side>+ consists
of \verb+<communication_clauses>+.

\item
The basic reserved words are {\em self}, {\em true} and
{\em otherwise}.
They are reserved in context, and may be used as channel names.

\begin{itemize}
\item
{\em self} may be used to iterate any process, including anonymous processes.
\item
{\em true} is an alternative name for process \verb+0 +.
\item
{\em otherwise} appears as the guard of the last clause of
\verb+<comparisons>+.
\end{itemize}

\noindent
Additional reserved words, used in Ambient Stochastic $\Pi$
Calculus are {\em enter}, {\em accept},
{\em exit}, {\em expel}, {\em merge}, {\em p2c}, {\em c2p}, {\em s2s}.

These words are all prefix operators, except for {\em merge}, which
is only reserved in context.

\item
An argument which is declared as a \verb+<logix_variable>+
in the added \verb+<parameter_list>+ of a \verb+<left_hand_side>+
is initially uninstantiated.

\item
Within a \verb+<logix_term>+, normal LOGIX recognition of variables
applies - {\em i.e.} variable names all begin with a capital letter
or underscore; to reference a \verb+<channel>+ whose name begins
with a lower case letter, within a \verb+<logix_term>+, refer to
\verb+"_var"(<channel>)+.


\item
A \verb+<logix_variable>+ may have a value which is an arbitrary LOGIX
term.
Such a value may be tested by a \verb+<logix_ask_guard>+,
instantiated or used as an argument in a \verb+<logix_goal>+ or by
a \verb+<logix_tell_guard>+.

\noindent
A \verb+<logix_variable>+ may be instantiated by an assignment
in a \verb+<logix_goal>+ within a \verb+<call>+:

\begin{verbatim}
    {<logix_variable> = <logix_term>}
\end{verbatim}

\item An
arbitrary  \verb+<logix_term>+ may be sent in a \verb+<message>+ by
the library \verb+<logix_goal>+ \verb+spi_send/2+, or received by the
library \verb+<logix_goal>+, \verb+spi_receive/2+:

\begin{verbatim}
  spi_send(<message_content>, <channel>)
  spi_receive(<channel>, <message_content>)
\end{verbatim}

\newpage
\noindent
{\em e.g.}

\begin{verbatim}
  spi_send({"A string", a(Tuple), [A, list | Tail]},
           "_var"(channel))

  spi_receive("_var"(channel), {String, Tuple, List})
\end{verbatim}

\item
The library \verb+<logix_goal>s+ \verb+spi_send/3 +,
\verb+spi_receive/3 +,\linebreak \verb+spi_send/4+, \verb+spi_receive/4+ may be
used as well, where the third argument is a multiplier (default 1), and
the fourth argument is an identifier (default ``sender'' or ``receiver'').

\item
The additive definition of \verb+<left_hand_side>+ is syntactic sugar
- {\em e.g.}

\begin{verbatim}
  P + (<argument_list>) ::= <right_hand_side>.
\end{verbatim}

\noindent
is equivalent to:

\begin{verbatim}
  P ::= << <argument_list> .
           P1 .
           P1 ::= <right_hand_side> >> .
\end{verbatim}

\item
The recursive definition of \verb+<right_hand_side>+ is syntactic
sugar - {\em e.g.}

\begin{verbatim}
  P ::= <communication1> ,
            {<logix_ask_guard>} , Q;
        <communication2> ,
            (<comparison> , R;
             otherwise , S).
\end{verbatim}

\noindent
is equivalent to:

\begin{verbatim}
  P ::= <communication1> ,
             << P1 .
                P1 ::= {<logix_ask_guard>} , Q >>;
        <communication2> ,
             << P2 .
                P2 ::= <comparison> , R ;
                       otherwise , S >>.
\end{verbatim}

\noindent
and

\begin{verbatim}
  P ::= <communication> , ( {<logix_ask_guard1>} , Q ;
                            {<logix_ask_guard2>} , R ) .
\end{verbatim}

\noindent
is equivalent to:

\begin{verbatim}
  P ::= <communication> , 
             << P1 .
                P1 ::= {<logix_ask_guard1>} , Q ;
                       {<logix_ask_guard2>} , R >> .
\end{verbatim}

\end{itemize}

\chapter{SPI commands}
\label{commands}

The macro commands supplied for SPI include and in some cases replace
the user macros of LOGIX.  They fall into three major
categories:

\begin{itemize}
\item Channel management and message transmission
\item Program execution
\item Debugging.
\end{itemize}

\section{Channel Management and Message Transmission Macros}

These macros may be useful in auxilliary LOGIX programs.
They may be used within an FCP goal; such use is not recommended.

\subsection{Create Channel - pc}

Create a new private channel.

\begin{verse}
pc(Channel) \\
pc(Channel,Creator,BaseRate) \\
pc(Channel,Creator,BaseRate,ComputeWeight)
\end{verse}

\noindent
The first macro creates an {\em instantaneous}
(infinite rate) channel.

\noindent
The second macro creates a {\em based} Channel,whose
name is derived from the string Creator, and whose base rate is specified by
the non-negative number BaseRate (When BaseRate = 0, the created
channel is a {\em sink} -
i.e. all sends and receives on the channel are discarded, and no actual
transmission occurs.)

\noindent
The third macro permits the user to specify a
\verb+<weighter_declaration>+, Weighter, for the new channel.

\noindent
Channel may be a string, in which case a LOGIX variable named with that
string is created.  The name may be used to refer to the channel
when using the ``ps'' and ``pr'' commands to send and receive messages,
or to inspect the channel - e.g.

\begin{verbatim}
  @pc(a)
  @ps([],a)
  @options(full)
  @a^
  a = spi.a(1)!
\end{verbatim}

\subsection{Send Message - ps}

Offer to send a message on a channel.

\begin{verse}
ps(Message,Channel) \\
ps(Message,Channel,Multiplier)
\end{verse}

\noindent
Multiplier is a positive integer;
the likelihood that Channel will be selected for transmission
increases with Multiplier.

\subsection{Receive Message - pr}

Offer to receive a message on a channel.

\begin{verse}
pr(Channel,Message) \\
pr(Channel,Message,Multiplier)
\end{verse}

\noindent
Multiplier is a positive integer, as above.

\subsection{Set Default Weighter - weighter}
\label{weighter macro}

Set the default weight computation.

\begin{verse}
weighter(Weighter)
\end{verse}

\noindent
Weighter  is an atom: a computation name
(string) or a tuple  Name(P1, $\cdots$ , Pn), where P1, $\cdots$ , Pn
are additional numeric parameters to the weight computation.


\section{Program Execution Macros}
\label{macros}

The basic LOGIX command to execute a program has the form:

\begin{verbatim}
  Path#Goal
\end{verbatim}

\noindent
The system creates a computation, uniquely identified by a positive
integer throughout the session.

\noindent
To execute a SPI program, {\em e.g.} RunTT in module bland in directory
boolean, call:

\begin{verbatim}
  boolean#bland#"RunTT"
\end{verbatim}

\noindent
The call above is an example of a Remote Process Call (RPC).

\noindent
The quotation marks around RunTT are necessary, since LOGIX
treats names beginning with a capital letter or an underscore as logix
variables.

\subsection{Execute Goals - run}
\label{runners}

Reset the session (as in \ref{reset}) and
execute all of the Goals as a single computation.

\begin{verse}
    run(Goals) \\
    run(Goals,Limit)
\end{verse}

\noindent
The first form continues
indefinitely; the second continues until Limit units of internal time have 
elapsed.  See  Appendix \ref{repeat} for details on specification 
of multiple goals.

\subsection{Execute Goals - record}
\label{recorders}
\begin{verse}
    record(Goals,File,Limit) \\
    record(Goals,File,Limit,Scale) \\
    record(Goals,File,Limit,Format) \\
    record(Goals,File,Limit,Scale,Format)
\end{verse}

\noindent
Like run it resets the session and
executes all of the goals until Limit; it also records their behavior
on the named file, optionally scaling the output times by multiplying
by Scale.  See  Appendix \ref{repeat} for
details on specification of multiple goals.  See  Appendix 
\ref{record} for details about the file and formatting.

\section{Execution Control}
\noindent
A computation may be  suspended ,  resumed  or  aborted.  You may also
inspect its resolvent - the set of unterminated processes  - see
Section \ref{debugger} for examples.

\subsection{Suspend Execution - suspend}
\label{suspend}

Suspend the current or the specified computation(s).

\begin{verse}
    s \\
    s(all) \\
    s(N)
\end{verse}

\noindent
The last form also resets the current computation number.
While the program is suspended, it may be inspected (see
\ref{spr}, \ref{cta}, \ref{rtr}, \ref{xtr}).

\subsection{Resume Execution - resume}
\label{resume}
Resume the current or the specified computation(s), as above.

\begin{verse}
    re \\
    re(all) \\
    re(N)
\end{verse}

\subsection{Abort Execution - abort}

Abort the current or the specified computation(s), as above.

\begin{verse}
    a \\
    a(all) \\
    a(N)
\end{verse}


\section{Debugging}

Debugging aids consist of inspection and execution control macros.

\subsection{Set Display Options - options}
\label{options}

Set new display control options and (optionally) return old ones.

\begin{verse}
    options(New) \\
    options(New,Old)
\end{verse}

\noindent
New  may be a single option or a LOGIX list of options.

\begin{itemize}
\item none:     Don't display any messages; this is the usual default.
\item active:   Display all active message actions (send, receive, dimer).
\item sender:   Display each message's sender in the form:
\begin{verse}
Process(ChannelName, Multiplier, Action)
\end{verse}
\item no\_sender: Only display a message's action; this is the usual default.
\end{itemize}

\noindent
An example list is:

\begin{verse}
    \verb+[active,sender]+
\end{verse}

\noindent
In the macros below, options may be specified explicitly in one variant
of most groups.  When the options are specified, they override the
global options set by the options macro above.

\subsection{Show a Channel - spc}

\begin{verse}
    spc(Channel) \\
    spc(Channel,Options)
\end{verse}

\noindent
display Channel.

\subsection{Show Goal - spg}

Display the goal of the current or of the specified computation.

\begin{verse}
   spg \\
   spg(N) \\
   spg(N,Options)
\end{verse}

\noindent
The last two forms also reset the current computation number.

\section{Debugging SPI}

\subsection{Show Resolvent - spr}
\label{spr}

Suspend the current or specified computation and display its resolvent
as above.

\begin{verse}
   spr \\
   spr(N) \\
   spr(N,Options)
\end{verse}

\noindent
To continue the computation, use the resume command
(see \ref{resume}).

\subsection{Display Communicating Channels - cta}
\label{cta}

Display communicating channels.

\label{cta}
\begin{verse}
    cta
\end{verse}

\subsection{Debug a Goal - pdb}

Debug a single RPC.

\begin{verse}
    pdb(RPC) \\
    pdb(RPC,Options)
\end{verse}

\noindent
The debugger provides help in reponse to the command ``help''.
See the document \underline{supplement.mss} for details of the debugger
commands.

\subsection{Create an Execution Tree - vtree}

Execute Goal, with respect to Path and prepare Tree.

\begin{verse}
    vtree(Path,Goal,Tree) \\
    vtree(Path,Goal,Tree,Depth)
\end{verse}

\noindent
Tree may be displayed using macros ``ctree'' and ``vtree'' below.
Depth is the depth of remote process call to be included in Tree -
if omitted, all goals are included.
For example, if Path is \verb+boolean#bland+
and goal is ``RunTT'', Tree represents the execution of the RPC:

\begin{verse}
    \verb+boolean#bland#"RunTT"+
\end{verse}

\noindent
Ordinarily, you should wait until the system becomes idle, or the
computation has been suspended before attempting to view Tree.
To view Tree, use either of the macros:

\begin{verse}
    ptree(Tree) \\
    ptree(Tree,Options)
\end{verse}

\noindent
See \ref{options} above for basic options.
Additional options which may be specified are:

\begin{itemize}
\item prefix:   Display Tree in prefix order; this is the default.
\item execute:  Display Tree in execution order.
\end{itemize}

\noindent
To close the execution tree:

\begin{verse}
    ctree(Tree)
\end{verse}

\noindent
This terminates the system's
participation in the execution of the computation.

\noindent
See Section \ref{vtree traces} for examples.

\section{Debugging }

\subsection{Show Ambient Tree - atr,ctr}
\label{xtr}

Display the ambient tree, a subtree, a node or a set of nodes.

\begin{verse}
   atr \\
   atr(AmbientSelector) \\
   ctr \\
   ctr(AmbientSelector)
\end{verse}

\noindent
The form of the display is specified
by the AmbientSelector (default is the entire tree).  An Ambient is
uniquely identified (within a run) by a positive integer.  Its
full identifier is a 2-tuple, \verb+<name>(<integer>)+.  The
AmbientSelector may specify:

\begin{itemize}
\item if omitted or the empty string, the entire tree.
\item if a positive integer, the entire subtree, starting with the
  designated ambient.
\item if a name, all ambients with that name;
  The name ``system'' designates the root of the tree as well as
  any other ambients whose full identifier is \verb+system(<integer>)+.
\item if a 2-tuple ({\em e.g.} \verb+cell(6)+) or a negative integer 
  ({\em e.g.} -6), the absolute value of the integer is the unique
  identifier of the single node displayed; in the former case,
  the name of the ambient is ignored.
\end{itemize}

\subsection{Show Resolvent - rtr}
\label{rtr}

Suspend the computation and display the resolvent as a tree of ambients.

\begin{verse}
   rtr \\
   rtr(AmbientSelector)
\end{verse}

\noindent
The active processes in each ambient are indented immediately below 
the node identifier.
To continue the computation, use the resume command
(see \verb+ref{resume}+).

\noindent
The AmbientSelector is treated as for atr/ctr above.

\section{Miscellaneous Macros}

\subsection{Reset the System - reset}
\label{reset}

This command closes all SPI activities,
effectively returning the system to its initial state,
except for the random seed, the ordinals assigned to
private channels and the current options.

\begin{itemize}
\item Activity of existing channels is terminated;
\item The list of existing public channels is discarded;
\item The current internal clock is reset to 0
      (See Chapter \ref{stochastic});
\item The current time limit is reset to a very large number;
\item No computation, ambient or process is terminated.
\end{itemize}

\noindent
The reset function is called automatically at the beginning of
any {\em run} or {\em record} command and whenever the internal
time Limit is exceeded
(See \ref{runners} and  \ref{recorders}).

\subsection{Input Commands - input}

Input the command file designated by Path.  

\begin{verse}
    i(Path) \\
    input(Path)
\end{verse}

\noindent
For example to execute
the commands contained in the file test in sub-directory scripts:

\begin{verse}
    input(scripts\#test)
\end{verse}

\subsection{Call a UNIX Command - \{$\cdots$\}}

Execute a UNIX command directly.

\begin{verse}
    \{Command\}
\end{verse}

\noindent
Examples:

\begin{verse}
    \{ls\} \\
    \verb+{"cat notes"}+
\end{verse}

\subsection{Display Named Variables - \^\ }

Display a named variable.

\begin{verse}
    VariableName\^\ 
\end{verse}

\noindent
Display all named LOGIX variables.

\begin{verse}
    \^\ 
\end{verse}

\subsection{Change Current Computation  }

Change the current computation according to the specified number.

\begin{verse}
    state(Number) 
\end{verse}

The current computation number is set to \verb+Number+ and
that computation's goal and state are displayed,

\chapter{Auxilliary LOGIX Procedures}
\label{auxilliary}

\section{record}
\label{record}

The spi\_record process can run a SPI process
and record its behavior.

\begin{verbatim}
  spi_record#run(<call program>, <time limit>)
  spi_record#run(<call program>, <file_name>, <time limit>)
  spi_record#run(<call program>, <file_name>, <time limit>, <scale>)
  spi_record#run(<call program>, <file_name>, <time limit>, <format>)
  spi_record#run(<call program>, <file_name>, <time limit>,
                 <scale>, <format>)
  spi_record#run(<call program>, <file_name>, <time limit>,
                 <format>, <scale>)
\end{verbatim}

\noindent
It is normally called by the macros {\em run} in Section
\ref{runners} and {\em record} in Section \ref{recorders}.

\begin{itemize}
\item
  \verb+run(hysteresis#"MODULE", 100)+

\noindent
starts the process  MODULE  in program module  hysteresis  and
terminates the run after 100 time units have elapsed.  To 
terminate the run prematurely, suspend the LOGIX computation
or enter  \verb+<control>+C  to kill LOGIX.

\item
  \verb+record(hysteresis#"MODULE", fff, 100)+

\noindent
does the same thing, and records the events of the run on file fff.
The elements of the file are lines which have one of three forms.
\begin{itemize}
\item
A real-valued {\em time}.
\item
\verb:+<procedure name> :, which records the start of a procedure.
\item
\verb:-<procedure name> :, which records the termination of a procedure.
\end{itemize}

\item
  \verb+record(hysteresis#"MODULE", fff, 100, 10)+

\noindent
does the same thing, and multiplies each time recorded in the file
by 10.
\end{itemize}

\noindent
The \verb+<format>+ argument may be one of ``none'', ``process'',
``creator'', ``full''.  The default is ``none''; the other three
annotate the records of communication with the name or identifier
of the channel over which the communication occurred.

\noindent
To analyze the file, producing a table suitable for plotting with
Matlab, use the PERL program ``spi2t'' - {\em e.g.}

\begin{verbatim}
  % spi2t fff
\end{verbatim}

creates a table, where column 1 is time, and columns $2 \cdots n$ are totals
of active processes.  A short file, with one long line, listing the
column (process) names, and n-1 lines associating process names with
array columns is also produced.  For example:

\begin{verbatim}
  fff.table  and  fff.names
\end{verbatim}

\noindent
Column one of the .table file is incremented approximately by 1 between
rows (lines).  To change the increment to another positive number, N,
add the argument N to the call to tally - e.g.

\begin{verbatim}
  % spi2t fff 0.1
\end{verbatim}

\noindent
To combine columns sums add terms of the form:

\begin{verbatim}
  <summed_column_name>+=<absorbed_column_name>
\end{verbatim}
{\em e.g.}
\begin{verbatim}
  % spi2t fff GENE+=BASAL+PROMOTED GENE+=ACTIVATED_TRANSCRIPTION
\end{verbatim}

\noindent
To rescale the output times, specify a negative rescale value - {\em e.g.}
to rescale output times by 1/10:
\begin{verbatim}
  % spi2t fff -10
\end{verbatim}

\noindent
To split the table into multiple 2-column files, suitable for gnuplot,
use the PERL program ``t2xys'' - e.g.

\begin{verbatim}
  % t2xys fff
  % gnuplot
  gnuplot> plot "fff.3" smooth unique
\end{verbatim}

\noindent
A short shell script, spixys, combines the functions with a call to gnuplot.

\section{repeat}
\label{repeat}
This LOGIX procedure is called by the {\em run} and
{\em record} macros (see \ref{runners} and
\ref{recorders}).

\noindent
The repeat process can run a quantified set of SPI
processes.

\begin{verbatim}
  repeat#run(<quantified process set>)
\end{verbatim}

\noindent
where:

\begin{verbatim}
  <quantified process set> ::=
      <external call>
      (<process set>)
      <repetition> * (<process set>)

  <process set> ::=
      <quantified process set>
      <process set> , <quantified process set>

  <repetition> ::= <integer>
\end{verbatim}

\noindent
A negative \verb+<repetition>+ is treated as zero.
\noindent
(See Appendix \ref{SPIBNF} for the definition of \verb+<external_call>+.)

\noindent
Examples:

\begin{itemize}
\item
\verb+repeat#run(64*(dimerization#"A_PROTEIN"))+
\item
\verb+repeat#run([6*(activator#"A_PROTEIN"),+ \linebreak
\verb+            activator#"A_GENE",repressor#"R_GENE"])+
\item
\verb+repeat#run([2*[activator#A_GENE,3*(repressor#R_GENE)],+ \linebreak
\verb+            hysteresis#module])+
\end{itemize}

\noindent
Note that the parentheses are necessary in the case of:

\begin{verbatim}
  <repetition>*(<external_call>)
\end{verbatim}

\noindent
Here is an example call to run (see Section \ref{bland}).

\begin{verbatim}
  repeat#run([3*(bland#"RunTT"),4*(bland#"RunFT")]) 
  <2> started
  It's false
  It's false
  It's false
  It's false
  It's true
  It's true
  It's true
  @spr
  <2> suspended
  bland # AndB.1.1.comm(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
  bland # TT.comm(public.b2!)
  bland # AndB.1.1.comm(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
  bland # TT.comm(public.b2!)
  bland # AndB.1.1.comm(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
  bland # TT.comm(public.b2!)
  bland # AndB.1.1.comm(Test.1.t, Test.1.f, public.b2!, AndB.1.x!)
  bland # TT.comm(public.b2!)
  @
\end{verbatim}

\section{Weight Computation for a Channel}
Channels with finite rates are weighted for selection using the
default computations in Section \ref{default rate}.

\noindent
The user may specify custom computations using the notation for\linebreak
\verb+<weighter_declaration>+
in Appendix \ref{SPIBNF}; the computation must be explicitly coded in
the module \verb+Logix/<emulator name>/spiweight.c+ .

\noindent
Module \verb+<emulator>/spiweight.c+ may be modified to
specify a custom computation.

\begin{itemize}
\item Choose a name for the computation, which is not used for some
other computation.  The name should be
alpha-numeric, and it should start with a lower-case letter (Embedded
underscores are permitted.)
\item Choose an integer to represent the computation, which is not used for
some other computation.
\item Add an entry to the ``weighter'' array in the specified form.
\item Add a case for the C-code of the computation to the switch(es)
in the function
\verb+spi_compute_bimolecular_weight+ and/or in the function
\verb+spi_compute_homodimerized_weight+ .
\item Re-install LOGIX - \verb+spiweight.c+ and the
appropriate emulator are automatically re-compiled.
\end{itemize}

\noindent
The arguments include the parameters of the
\verb+<weighter_declaration>+ in their order of declaration in
the array ``argv''; the argument ``argn'' is the size of the
array.

\noindent
The computed weight should be stored in ``result''.  Two
examples of custom computation, named ``square'' and ``poly''
are included in the module.

\newpage

\bibliographystyle{plain}
\bibliography{tutorial}

\end{document}
