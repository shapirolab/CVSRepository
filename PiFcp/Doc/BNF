BNF for PiFcp

<program>              ::= <process_definitions> .

<process_definitions>  ::= <process>
                           <process> . <process_definitions>

<process>              ::= <left_hand_side> :- <right_hand_side>

<left_hand_side>       ::= <atom>
                           <atom>+<channel>
                           <atom>+(<channel_list>)

<atom>                 ::= <name>
                           <name>(<channel_list>)

<channel_list>         ::= <channel>
                           <channel>, <channel_list>

<right_hand_side>      ::= <synchronized_clauses>
                           <comparison_clauses>
                           <body>

<synchronized_clauses> ::= <synchronized_clause> 
                           <synchronized_clause> ; <synchronized_clauses>

<synchronized_clause>  ::= <synchronized_guard> | <body>

<synchronized_guard>   ::= <communication>
                           <communication> | <synchronized_guard>

<communication>        ::= <receive>
                           <send>

<receive>              ::= <channel> ? <message>

<send>                 ::= <channel> ! <message>

<comparison_clauses>   ::= <comparison_clause> ; otherwise | <body>
                           <comparison_clause> ; <comparison_clauses>

<comparison_clause>    ::= <comparison> | <body>
                           <comparison> | <synchronized_clause>

<comparison>           ::= <compare>
                           <compare> & <comparison>

<compare>              ::= <channel> =?= <channel>
                           <channel> =\= <channel>

<message>              ::= []
                           {<channel_list>}

<body>                 ::= <call>
                           <call> , <body>

<call>                 ::= <atom>
                           <name>( <substitution_list> )
                           <communication>
                           << <new_scope> >>
                           true
                           <external_call>
                           <logix call>

<substitution_list>    ::= <substitution>
                           <substitution> , <substitution_list>

<substitution>         ::= <channel> = <channel>

<new_scope>            ::= <channel_list> . <scope_content>
                           <scope_content>

<scope_content>        ::= <right_hand_side>
                           <right_hand_side> . <process_definitions>

<external_call>        ::= <logix_node_name>#<atom>
                           <logix_node_name>#<external_call>

<logix_call>           ::= <logix_node_name>#<logix_atom>
                           <logix_node_name>#<logix_call>

Primitives:


A <channel> is an alpha-numeric string, beginning with a lower case letter,
which may contain  an underscore (_) character, or it is just an underscore
character.  By convention the <channel> "_" is anonymous; it may only be
used in a <receive> <channel_list>, where it matches any <channel> which
is sent in the corresponding position.


A <name> is an alpha-numeric string, beginning with a upper case letter, which
may contain an underscore (_) character.


A <logix_node_name> is a non-empty string.


Notes:


The "new" predicate has been subsumed into a prefix <channel_list> of
a <new_scope> and the added <channel_list> of a <process>.

The <channel>s in the <arguments> of a <process> are provided by a caller.
A <channel> may be "extruded" from a <process> by a <send> to such an argument
channel.


If a <process> is declared at level one of a <program> definition, it may be
called by an external process.


Nested "new" processes are scoped with angle brackets (see definition of
<new_scope>).


Channel typing has been omitted.


A <logix_atom> is any Logix procedure call.


Reserved atoms are not (yet) specified, except for "true", which should only
be needed as the only <call> in the <body> of a <synchronized_clause>.


The recursive definition of <synchronized_guard> is syntactic sugar - e.g.

    p :- <communication1> | <synchronized_guard1> | q;
         <communication2> | <synchronized_guard2> | r.

is equivalent to:

    p :- <communication1> | p1;
         <communication2> | p2.

    p1 :- <synchronized_guard1> | q.

    p2 :- <synchronized_guard2> | r.
