The process multiple may be used to run sequential processes with
a single command.

For the definition of bracketed items (e.g. <declarations>), see
multiple-bnf.txt.

The call to multiple has two arguments:

    multiple#run(Declarations, Reports)

1.The first argument declares the multiple runs:

   a. a text file name - the data of the file is a <run_declarations> ;

   b. an immediate quoted string - a <declarations> .

2. The second arguments is A stream of status reports, giving the state
   of each run at termination; the stream is closed after the last run.

The <run_declarations> are parsed, and a list of runs is prepared.

For each <process_declarations> N runs are prepared, where the number
of arguments in each <tell> is a multiplier in the product N.

For each run:

1. Initialization:

   a. The spi_monitor is reset;

   b. For each <public_variable_name> defined for the run, its corresponding
      <expression> is compiled.

      When the expression involves an operator or function, it is evaluated
      - this may result in failure, when the <expression> includes a 
      <public_variable_name>.

   c. Each <public_variable_name> defined for the run is un-bound.

   d. Each <public_variable_name>  defined for the run, is bound to the
      corresponding compiled <expression>.

      When the <expression> is a <public_variable_name> the value of the
      (re)bound <public_variable_name> may be:

        (1) conserved from the previous run (e.g. A(A));

        (2) unified with some other <public_variable_name> (e.g. A(B));

        (3) or undefined (e.g.A(_)).

      In those three cases, the <expression> is NOT evaluated.

   e. The <run_parameters> are compiled:

      (1) The <expression>s for the <limit> and <scale> paremeters are 
          evaluated when the <expression> involves an  operator or a
          function - this may result in failure, when the <expression>
          includes a <public_variable_name> which is uninstantiated or
          is improperly instantiated.  The resultant values should be
          positive.

      (2) <format> may be a <public_variable_name>; in that case, the
	  value of the variable must be instantiated to a legitimate
          value for each component run.

          Legitimate values of <format> are none, process, creator,
          full, ambient and atrace.  The first five invoke spi_record
          to produce the output file; atrace invokes ambient_list to
          produce the output file.

      (3) <file_name> may be a <public_variable_name>; in that case,
          its value must be instantiated to a string for each component
          run.

          The name of the file on which the output data is recorded is
          derived from <file_name> by concatenation of the string, the
          character "_" and the run index.

   f. The <call_list> is compiled.

   Note that when a <public_variable_name> is determined for a run, its 
   value may depend on a previously defined <public_variable_name>, but
   NOT on another <public_variable_name> compiled for the same run.

2. Execution:

   a. The evaluated <run_parameters> are applied, preparing to run
      or record the <call_list> (see SpiFcp/Documentation/record.txt).

   b. The compiled <call_list> is executed.

3. Termination:

   a. When the run terminates, its termination outcome is added to the
      status reports - this may be:

      (1) done
          normal termination;

      (2) done @ <internal time> : seconds = <elapsed time>
          internal run <limit> exceeded.

      (3) idle(<internal_time>)
          run is blocked and cannot continue.

      (4) aborted_run
          the multiple run was aborted.

      (5) failed(<reason for failure>)
          failure termination.

   b. The user may suspend or abort the multiple run at any time.


Examples of <declarations> files
--------------------------------

1. X([]):1|utils#integer_to_dlist(69,List,X)

   The single process terminates with "done".

2. E(_,2) : limit(10) | E := 1

   The first process terminates "idle(0.0)" since E is initially
   uninstantiated.
   The second process terminates "failed(utils # evaluate, 1 =\= 2)".
   Note that the first process "records" in the file named record,
   while the second "records" in record_1.

3. Base(10),L(2,3,4):limit(L*Base)|circadian#go

   The first process terminates "done @ 20.001186 : seconds = 12".
   The second process terminates "done @ 30.00204 : seconds = 22".
   The third process terminates "done @ 40.003322 : seconds = 38".

4. To execute all of the modules in Aspic-release/BioSpi/Examples:

   Module(eg1,eg3):10|Module#"Cytoplasm".
   Module(porin,symporter_comm,complex_merge,receptor_endo,vesicle_merge,
          complex,vesicle):10|Module#"System".

Note that multiple works for both languages, spifcp and biospi.
