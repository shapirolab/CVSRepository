#!/usr/local/bin/perl

# Constant definitions

#see sys/resource.h
$PRIO_MIN     = -20;          # SGI - not on Solaris
$PRIO_MAX =      20;          # SGI - not on Solaris
$PRIO_PROCESS  =  0;
$PRIO_PGRP     =  1;
$PRIO_USER     =  2;

$NICE_OFF      = -$PRIO_MIN;
$NICE_MAX      =  $PRIO_MAX + $NICE_OFF;

$NICE_DEFAULT  = 20;          # Default nice value of system.
$NICE_COVENTRY = 30;          # Must be ge $NICE_DEFAULT + 2.
$NICE_RADIX    = 10;          # Controls the ranges for nice changes.
$NICE_INCR     =  1;          # Set 0 to permit only one greedy process
                              # per user, outside of coventry.
$BAN_GANGS     =  1;          # Set to 0 to spread Greedy gang processes over
                              # an interval of non-dteriorating priorities.

$MONITOR_DELAY = 60;          # Main loop iteration delay in seconds.
$THRESHHOLD    = 60;          # Minimum elapsed seconds before changing nice.
$GREED_BOUND   =  5;          # Minimum used time between iterations before
                              # changing nice.
$QUERY_MINIMUM =  1;          # Default minimum minutes of displayed processes.

# see sys/schedctl.h            SGI only
$NDPLOMAX      = 128;         # Best low Non-deteriorating priority
$NDPLOMIN      = 254;         # Worst "   "   " " "  "  "    "  "

$NDPRI_DEFAULT = $NDPLOMAX
    - $BAN_GANGS*($NICE_COVENTRY - $NICE_DEFAULT);

$NDPRI_OFFSET  = $NDPRI_DEFAULT - $NICE_DEFAULT;
$NDPRI_OFFSET + $NICE_COVENTRY <= $NDPLOMIN or
    die "Inconsistentcy between nice range and ndpri range."; 

# Default exclusion hashes.

%users = (
	  daemon => 1,
	  ftp    => 1,
	  lp     => 1,
	  root   => 1,
	  60001  => 1,
);

# Maximum length of a command name is 30 characters (see below).
%commands = (
	     biod => 1,
	     csh  => 1,
	     ftpd => 1,
	     nfsd => 1,
	     rshd => 1,
	     sh   => 1,
	     tcsh => 1,
# Added for Solaris
	     ncdwm => 1,
	     xterm => 1,
	     "/X11/bin/xterm" => 1,
	     "-tcsh" => 1,
	     "/bin/ksh" => 1,
);

# Global variables

$query  = "";
$pscomm = "";

$count  = 0;                  # Number of processes in %current_processes
$debug  = defined($ENV{"DEBUG_COVENTRY"});
$stop   = 0;

undef(@coventry);             # A list of processes - normally sorted.

undef(%previous_processes);   # A hash of processes, indexed by Process Id.
undef(%current_processes);    # A hash of processes, indexed by Process Id.
undef(%freed_processes);      # A hash of processes, indexed by user(nice).

if ($debug) {# debug
#$NICE_INCR     = 0;
#$NICE_RADIX    = 1;
#$MONITOR_DELAY = 10;
#$GREED_BOUND   = 0;
#$THRESHHOLD    = 0;
}# endif

# Initialization and argument handling

# If first argument = -Qn - display processes with elapsed time >= n minutes.
# Default for n is $QUERY_MINIMUM.

$query = shift(@ARGV) if @ARGV[0] =~ /-Q(\d*)/;

# If first argument (after -Qn) is a number, 
if ($#ARGV >= 0) {
  $args = "@ARGV";
  if ($ARGV[0] =~ /\d+.*/) {
    $args = "-p $args";
  }
}
else {
    $args = "-A";
}

# Handle up to thirty character command name.
$pscomm =
    "ps $args -o user,nice,time,pid,pgid,class," .
        "comm=aaaaaaaaaabbbbbbbbbbcccccccccc";
if ($debug) {# debug
  print "command = ", $pscomm ,"\n";
}# endebug

    exit 0 if query_processes($query);

$SIG{"INT"} = "clean_up";
$SIG{"QUIT"} = "clean_up";

# Main loop

while (not $stop) {

    # 1.
    collect_current_processes();

    # 2.
    drop_terminated_processes();

    # 3.
    send_to_coventry();

    # 4.
    free_from_coventry();

    # 5.

    undef(%previous_processes);
    %previous_processes = %current_processes;
    undef(%freed_processes);

    sleep($MONITOR_DELAY);
}

# The End


# Signal handler

# clean_up returns processes which are currently in coventry, to society. 

sub clean_up
{
    my $process;

    foreach $process (@coventry) {
if ($debug) {# debug
  print_refed_process("returned to society", $process);
}# endebug
	setnice($process, $process->[1]);
    }
    exit 0;
}

# auxiliary subroutines

# parse_process extracts interesting parameters from a process status line
# produced by ps.  The status line is in $_ on entry.
#
# Return 1 if the process is not excluded by one of the exclusion hashes.
#
# Note: This subroutine should be modified as necessary per platform.
#       It works fine on SGI and Solaris System V platforms.

sub parse_process
{
    my $time;
    my $user, $nice, $seconds, $pid, $pgid, $class, $comm;

    my $leader = 0;

    ($user, $nice, $time, $pid, $pgid, $class, $comm) = split;
    $class =~ tr/A-Z/a-z/;

    if ($class eq "gn" || $class eq "gb") {
	$_ = `getndpri $pid`;
	return undef if !/^ndpri.* = (\d+)$/;
	$nice = (int $1) ? $1 - $NDPRI_OFFSET : $NICE_DEFAULT;
    }
    if ($users{$user} || $commands{$comm} || 
	($class ne "ts" && $class ne "gn" && $class ne "gb") ||
	$NICE_DEFAULT > $nice || $nice > $NICE_COVENTRY) {
	return undef;
    }
    if ($nice !~ /\s*\d\d\s*/) {
	$nice = getpriority($PRIO_PROCESS, $pid) +$NICE_OFF;
	print "$user($class) - $comm($pid), has nice = $nice\n";
    }

    $seconds = 0;
    if ($time =~ /(\d+)-(.*)\Z/) {
	$seconds = 86400*$1;
	$time = $2;
    }
    if ($time =~ /(\d+):(\d+:\d+)\Z/) {
	$seconds += 3600*$1;
	$time = "$2";
    }
    $time =~ /(\d+):(\d\d)/;
    $seconds += 60*$1 + $2;
    return [$user, $nice, $seconds, $pid, $pgid, $class, $comm];

}

# sortrefs is called by the sort function to compare two process references.
#
# The arguments $a and $b are the two process references.
#
# A process reference points to an array of 6 arguments in collation order
# of the first 4 elements.

sub sortrefs #context {$a, $b}
{
    my $i, $reply;

    for ($i = 0; $i < 4; $i++) {
	$reply = $a->[$i] cmp $b->[$i];
	return $reply if $reply;
    }
    return 0;
}

# setnice sets the nice value for a process.
#
# The arguments are the process id and the nice value.

sub setnice #(process, nice)
{
    my $process;
    my $user, $unnice, $seconds, $pid, $pgid, $class, $comm;

    $process = shift;
    my $nice = shift;

    ($user, $unnice, $seconds, $pid, $pgid, $class, $comm) = @{$process};

    if ($class eq "ts") {
	return setpriority($PRIO_PROCESS, $pid, $nice-$NICE_OFF);
    }
    else {
      # $class eq "gn" || $class eq "gb"
	$nice += $NDPRI_OFFSET;
	return `setndpri $nice $pid`;
    }
}

# query process conditionally displays all processes of interest, whose
# elapsed time exceeds a parameterized value.
#
# The processes are displayed if the argument has the form -Q or -Qn, where
# n is a non-negative integer.  The default for n is $QUERY_MINIMUM.

sub query_processes #(query)
{
    my $minmins, $minsecs, $mins, $secs;
    my $user, $nice, $seconds, $pid, $pgid, $class, $comm;
    my $title;
    my @display_processes;

    if (shift(@_) =~ /-Q(\d*)/) {
	$minmins = $1 ne "" ? $1 : $QUERY_MINIMUM;
	$minsecs = 60*$minmins;
	collect_current_processes();
	foreach (sort(sortrefs values(%current_processes))) {
	    push(@display_processes, $_) if ($_->[2] >= $minsecs);
	}
	$title = (($minmins > 0) ?
		  ("with at least $minmins elapsed minute" .
		   ($minmins == 1 ? "" : "s")) : "") . "\n";
	print_process_count($#display_processes+1, $title);
	if ($#display_processes >= 0) {
	    foreach (@display_processes) {
		($user, $nice, $seconds, $pid, $pgid, $class, $comm) = @{$_};

		$mins = int ($seconds/60);
		$secs = $seconds % 60;

		$secs = "0$secs" if $secs < 10;
		
		if ($seconds >= $minsecs) {
		    if ($class eq "gn" || $class eq "gb") {
			$nice = `ps -p $pid -o pri=`;
			$nice =~ /^\s*(\d+)\s*$/;
			$nice = 'g' . $1;
		    }
		    print "    $user($nice) - $mins:$secs - $comm($pid)\n";
	}
	    }
	}
	return 1;
    }
    return 0;
}

# Development and debugging aids

# format_time produces a formatted string from the current time of day
#
#          hour:minute:second

sub format_time
{
    my $hr, $min, $sec;

    ($sec, $min, $hr) = localtime(time());
    return sprintf("%2d:%02d:%02d", $hr, $min, $sec);
}

# print_refed_process prints a referenced process.
#
# Its arguments are a title and a process reference.

sub print_refed_process #(title, reference)
{
    my $title = shift;
    my $ref = shift;
  
    my @list;

    for (my $i = 0; $i < 7; $i++) {
	push @list, $ref->[$i];
    }
    print sprintf("%s - $title: %s\n",
		  format_time(), join(", ", @list));
}


# print_process_count prints a count of processes and a title.

sub print_process_count #(count, title)
{
    my $count = shift;
    my $title = shift;
    my $time;

    $time = format_time();
    print "$time - there ", $count <= 1 ?
	     ("is " . ($count == 0 ? "no" : "one") . " process") : 
	     "are $count processes",
	$title ? " $title\n" : "\n";
}

# algorithm subroutines


# collect_current_processes builds a fresh hash of current processes from
# the reply of the ps command.
#
# It calls parse_process to identify excluded processes and to extract the
# components of each process from the list of lines returned by the command.

sub collect_current_processes
{
    my @ps_lines;
    my $process;

    undef(%current_processes);
    $count = 0;

    @ps_lines = `$pscomm`;
    shift(@ps_lines);
    foreach (@ps_lines) {
	$process = parse_process();
	if (defined($process)) {
	    $count++;
	    $current_processes{$pid} = $process;
	}
    }

}

# drop_terminated_processes removes any process in coventry which is not
# a current processes.

sub drop_terminated_processes
{
    my $current, $pid, $process;

if ($debug) {# debug
    if ($debug && !defined(%current_processes)) {
	print "No current processes\n";
    }
}# endebug

    @_ = @coventry;
    undef(@coventry);
    foreach $process (@_) {
	$pid = $process->[3];
	$current = $current_processes{$pid};
	if (defined($current)) {
	    if ($current->[1] == $NICE_COVENTRY) {
		push @coventry, $process;
		delete $current_processes{$pid};
	    }
	    # otherwise, someone has altered its nice value - drop it!
elsif ($debug) {# debug
  print_refed_process("taken from coventry", $process);
}# endebug
        }
elsif ($debug) {# debug
  print_refed_process("stopped in coventry", $process);
}# endebug

    }
}

# send_to_coventry examines all of the current processes and sends to
# coventry any process which has used too much time for its current
# nice value, and too much time during the last iteration.

sub send_to_coventry
{
    my $user, $nice, $seconds, $pid, $pgid, $class, $comm;
    my $changed, $previous, $process, $used;
    my $bound, $freedid, $niced, $oldsecs;
    my @pids;

    foreach $process (values(%current_processes)) {
	($user, $nice, $seconds, $pid, $pgid, $class, $comm) = @{$process};
	if ($BAN_GANGS && ($class eq "gn" || $class eq "gb")) {
	    push @pids, $pid;
	    push @coventry, $process;
if ($debug) {# debug
  print_refed_process("banned gang process", $process);
}# endebug
	    next;
	}
	$previous = $previous_processes{$pid};
	if (defined($previous)) {
	    $used = $seconds - $previous->[2];
	    $bound = ($nice >= $NICE_COVENTRY);
	    if ($bound || $used >= $GREED_BOUND) {
		$changed = 
		    $seconds >= 
			$THRESHHOLD*($NICE_RADIX**($nice - $NICE_DEFAULT))
			    && ! $bound;
		$nice += $NICE_INCR if $changed;
		$freedid = "$user($nice)";
		$process =
		    [$user, $nice, $seconds, $pid, $pgid, $class, $comm];
		if (defined($freed_processes{$freedid}) || $bound) {
		    push @pids, $pid;
		    push @coventry, $process;
if ($debug) {# debug
  if ($bound) {
    print_refed_process("to coventry forever", $process);
  }
  else {
    print_refed_process($changed ? "changed to coventry"
		                 : "banned from society", $process);
  }
}# endebug
		}
		else {
		    # Leave it in society - no other greedy process with
		    # this nice user.
		    $freed_processes{$freedid} = $process;
		    if ($changed) {
			setnice($process, $nice);
if ($debug) {# debug
  print_refed_process("re-niced in society", $process);
}# endebug
		    }
		}
		    
	    }
	}
    }
    foreach $pid (@pids) {
	$process = delete $current_processes{$pid};
        setnice($process, $NICE_COVENTRY);
    }
    @coventry = sort(sortrefs @coventry);
}

# free_from_coventry restores processes from coventry to current society,
# for each of which there is no other current process, belonging to the
# same user, which was just freed from coventry and has the same nice value.

sub free_from_coventry
{
    my $user, $nice, $seconds, $pid, $pgid, $class, $comm;
    my $banned, $freedid, $social, $user;

    my @banned_processes = @coventry; # coventry is sorted.

    undef(@coventry);
    while ($#banned_processes >= 0) {
	$banned = shift(@banned_processes);
	($user, $nice, $seconds, $pid, $pgid, $class, $comm) = @{$banned};
	$freedid = "$user($nice)";
	if (defined($freed_processes{$freedid}) ||
	    $nice == $NICE_COVENTRY ||
	    ($BAN_GANGS && ($class eq "gn" || $class eq "gb"))) {
	    # A process of this user with the same nice value has already
	    # been freed, or this process has been permanently relegated! 
	    push(@coventry, $banned);
	}
	else {
	    $current_processes{$pid} = $banned;
	    setnice($process, $nice);
	    $freed_processes{$freedid} = $banned;
if ($debug) {# debug
  print_refed_process("freed from coventry", $banned);
}# endebug
        }
    }
}

