#!/usr/local/bin/perl

# Constant definitions

#see sys/resource.h
$PRIO_MIN     = -20;         # On SGI - not on Solaris
$PRIO_MAX =      20;         # On SGI - not on Solaris
$PRIO_PROCESS  =  0;
$PRIO_PGRP     =  1;
$PRIO_USER     =  2;

$NICE_OFF      = -$PRIO_MIN;
$NICE_MAX      =  $PRIO_MAX + $NICE_OFF;

$NICE_DEFAULT  = 20;          # Default nice value of system
$NICE_COVENTRY = 30;          # Must >= $NICE_DEFAULT + 2
$NICE_RADIX    = 10;          # Controls the ranges for nice changes.
$NICE_INCR     =  1;          # Set 0 to permit only one greedy process
                              # per user outside of coventry

$MONITOR_DELAY = 60;          # Main loop iteration delay in seconds.
$THRESHHOLD    = 60;          # Minimum elapsed seconds before changing nice.
$GREED_BOUND   =  5;          # Minimum used time between iterations before
                              # changing nice.
$QUERY_MINIMUM =  1;          # Default minimum minutes of displayed processes.

# Default exclusion hashes.

%users = (
	  daemon => 1,
	  ftp    => 1,
	  lp     => 1,
	  root   => 1,
	  60001  => 1,
);

%queues = (
	   bg => 1,
	   BG => 1,
	   bt => 1,
	   BT => 1,
	   dl => 1,
	   DL => 1,
	   os => 1,
	   OS => 1,
	   rt => 1,
	   RT => 1,
);

# Maximum length of a command name is 30 characters (see below).
%commands = (
	     csh  => 1,
	     ftpd => 1,
	     nfsd => 1,
	     rshd => 1,
	     sh   => 1,
	     tcsh => 1,
# Added for Solaris
	     xterm => 1,
	     "/X11/bin/xterm" => 1,
	     "-tcsh" => 1,
	     "/bin/ksh" => 1,
);

# Global variables

$query  = "";
$pscomm = "";

$count  = 0;                  # Number of processes in %current_processes
$debug  = defined($ENV{"DEBUG_COVENTRY"});
$stop   = 0;

undef(@coventry);             # A list of processes - normally sorted.

undef(%society);              # A hash of processes, indexed by Process Id.
undef(%current_processes);    # A hash of processes, indexed by Process Id.

if ($debug) {# debug
$NICE_INCR      = 0;
$NICE_RADIX    =  1;
#$MONITOR_DELAY = 5;
#$GREED_BOUND   = 0;
#$THRESHHOLD    = 0;
}# endif

# Initialization and argument handling

# If first argument = -Qn - display processes with elapsed time >= n minutes.
# Default for n is $QUERY_MINIMUM.

$query = shift(@ARGV) if @ARGV[0] =~ /-Q(\d*)/;

# If first argument (after -Qn) is a number, 
if ($#ARGV >= 0) {
  $args = "@ARGV";
  if ($ARGV[0] =~ /\d+.*/) {
    $args = "-p $args";
  }
}
else {
    $args = "-A";
}

# Handle up to thirty character command name.
$pscomm =
    "ps $args -o user,pid,nice,class,time," .
    "comm=aaaaaaaaaabbbbbbbbbbcccccccccc";
if ($debug) {# debug
  print "command = ", $pscomm ,"\n";
}# endebug

    exit 0 if query_processes($query);

$SIG{"INT"} = "clean_up";
$SIG{"QUIT"} = "clean_up";

# Main loop

while (not $stop) {

    # 1.
    collect_current_processes();

    # 2.
    drop_terminated_processes();

    # 3.
    send_to_coventry();

    # 4.
    free_from_coventry();

    # 5.

    undef(%society);
    %society = %current_processes;

    sleep($MONITOR_DELAY);
}

# The End


# Signal handler

# clean_up returns processes which are currently in coventry, to society. 

sub clean_up
{
    my $process;

    foreach $process (@coventry) {
if ($debug) {# debug
  print_refed_process("returned to society", $process);
}# endebug
	setnice($process->[3], $process->[1]);
    }
    exit 0;
}

# auxiliary subroutines

# parse_process extracts interesting parameters from a process status line
# produced by ps.  The status line is in $_ on entry.
#
# Return 1 if the process is not excluded by one of the exclusion hashes.
#
# Global variables set are:
#    $user,    $nice,       $seconds,        $pid,     $comm
# User name, nice value, elapsed seconds, process id, command
#
# Note: This subroutine should be modified per platform.

sub parse_process
{
    my $time;

    ($user, $pid, $nice, $class, $time, $comm) = split;

    if ($users{$user} or $commands{$comm} or $queues{$class} ) {
	return 0;
    }

    if ($nice !~ /\s*\d\d\s*/) {
	$nice = getpriority($PRIO_PROCESS, $pid) +$NICE_OFF;
    }

    $seconds = 0;
    if ($time =~ /(\d+)-(.*)\Z/) {
	$seconds = 86400*$1;
	$time = $2;
    }
    if ($time =~ /(\d+):(\d+:\d+)\Z/) {
	$seconds += 3600*$1;
	$time = "$2";
    }
    $time =~ /(\d+):(\d\d)/;
    $seconds += 60*$1 + $2;

    return 1;
}

# sortrefs is called by the sort function to compare two process references.
#
# The arguments $a and $b are the two process references.
#
# A process reference points to an array of 5 arguments in collation order.

sub sortrefs #context {$a, $b}
{
    my $i, $reply;

    for ($i = 0; $i < 4; $i++) {
	$reply = $a->[$i] cmp $b->[$i];
	return $reply if $reply;
    }
    return 0;
}

# setnice sets the nice value for a process.
#
# The arguments are the process id and the nice value.

sub setnice #(processid, nice)
{
    my $pid = shift;
    my $nice = shift;

    return setpriority($PRIO_PROCESS, $pid, $nice-$NICE_OFF);
}

# query process conditionally displays all processes of interest, whose
# elapsed time exceeds a parameterized value.
#
# The processes are displayed if the argument has the form -Q or -Qn, where
# n is a non-negative integer.  The default for n is $QUERY_MINIMUM.

sub query_processes #(query)
{
    my $minmins, $minsecs;
    my $user, $nice, $seconds, $comm, $pid, $mins, $secs;
    my $title;
    my @display_processes;

    if (shift(@_) =~ /-Q(\d*)/) {
	$minmins = $1 ne "" ? $1 : $QUERY_MINIMUM;
	$minsecs = 60*$minmins;
	collect_current_processes();
	foreach (sort(sortrefs values(%current_processes))) {
	    push(@display_processes, $_) if ($_->[2] >= $minsecs);
	}
	$title = (($minmins > 0) ?
		  ("with at least $minmins elapsed minute" .
		   ($minmins == 1 ? "" : "s")) : "") . "\n";
	print_process_count($#display_processes+1, $title);
	if ($#display_processes >= 0) {
	    foreach (@display_processes) {
		$user = $_->[0]; 
		$nice = $_->[1];
		$seconds = $_->[2];
		$pid = $_->[3];
		$comm = $_->[4];

		$mins = int ($seconds/60);
		$secs = $seconds % 60;

		$secs = "0$secs" if $secs < 10;
		
		if ($seconds >= $minsecs) {
		    print
			"    $user($nice) - $mins:$secs - $comm($pid)\n";
		}
	    }
	}
	return 1;
    }
    return 0;
}

# Development and debugging aids

# format_time produces a formatted string from the current time of day
#
#          hour:minute:second

sub format_time
{
    my $hr, $min, $sec;

    ($sec, $min, $hr) = localtime(time());
    return sprintf("%2d:%02d:%02d", $hr, $min, $sec);
}

# print_refed_process prints a referenced process.
#
# Its arguments are a title and a process reference.

sub print_refed_process #(title, reference)
{
    my $title = shift;
    my $ref = shift;
  
    my @list;

    for (my $i = 0; $i < 5; $i++) {
	push @list, $ref->[$i];
    }
    print sprintf("%s - $title: %s\n",
		  format_time(), join(", ", @list));
}


# print_process_count prints a count of processes and a title.

sub print_process_count #(count, title)
{
    my $count = shift;
    my $title = shift;
    my $time;

    $time = format_time();
    print "$time - there ", $count <= 1 ?
	     ("is " . ($count == 0 ? "no" : "one") . " process") : 
	     "are $count processes",
	$title ? " $title\n" : "\n";
}

# algorithm subroutines


# collect_current_processes builds a fresh hash of current processes from
# the reply of the ps command.
#
# It calls parse_process to identify excluded processes and to extract the
# components of each process from the list of lines returned by the command.

sub collect_current_processes
{
    my @ps_lines;

    undef(%current_processes);
    $count = 0;

    @ps_lines = `$pscomm`;
    shift(@ps_lines);
    foreach (@ps_lines) {
	if (parse_process() and
	    $NICE_DEFAULT <= $nice and $nice <= $NICE_COVENTRY) {
	    $count++;
	    $current_processes{$pid} = [$user,$nice,$seconds,$pid,$comm];
	}
    }

}

# drop_terminated_processes removes any process in coventry which is not
# a current processes.

sub drop_terminated_processes
{
    my $current, $pid, $process;

if ($debug) {# debug
    if ($debug and !defined(%current_processes)) {
	print "No current processes\n";
    }
}# endebug

    @_ = @coventry;
    undef(@coventry);
    foreach $process (@_) {
	$pid = $process->[3];
	$current = $current_processes{$pid};
	if ($current) {
	    if ($current->[1] == $NICE_COVENTRY) {
		push @coventry, $process;
		delete $current_processes{$pid};
	    }
	    # otherwise, someone has altered its nice value - drop it!
elsif ($debug) {# debug
  print_refed_process("taken from coventry", $process);
}# endebug
        }
elsif ($debug) {# debug
  print_refed_process("stopped in coventry", $process);
}# endebug

    }
}

# send_to_coventry examines all of the current processes and sends to
# coventry any process which has used too much time for its current
# nice value, and too much time during the last iteration.

sub send_to_coventry
{
    my $banned_processes, $nice, $pid, $process, $previous, $seconds, $used;
    my @pids;

    foreach $process (values(%current_processes)) {
	$pid = $process->[3];
	$previous = $society{$pid};
	if ($previous) {
	    $nice = $process->[1];
	    $seconds = $previous->[2];
	    $used = $process->[2] - $seconds;

	    if ($nice == $NICE_COVENTRY or
		(($nice+=NICE_INCR) == $previous->[1] and
		 $used >= $GREED_BOUND and
		 $seconds >= 
		     $THRESHHOLD*(NICE_RADIX**($nice - $NICE_DEFAULT
					       - $NICE_INCR)))) {

		push @pids, $pid;
		push @coventry,
		    [$process->[0], $nice, $process->[2], $pid, $process->[4]];
	    }
	}
    }
    foreach $pid (@pids) {
#if ($debug) {# debug
  print_refed_process("banned from society", $current_processes{$pid});
#}# endebug
	delete $current_processes{$pid};
        setnice($pid, $NICE_COVENTRY);
    }
    @coventry = sort(sortrefs @coventry);
}

# free_from_coventry restores processes from coventry to current society,
# for each of which there is no other current process, belonging to the
# same user, which has the same nice value.

sub free_from_coventry
{
    my $banned, $social;

    my @banned_processes = @coventry; # coventry is sorted.
    my @social_processes = sort(sortrefs values(%current_processes));

    undef(@coventry);
    while ($#banned_processes >= 0) {
	$banned = shift(@banned_processes);
	if ($banned->[1] == $NICE_COVENTRY) {
	    # This process has been permanently relegated! 
	    push(@coventry, $banned);
	}
	else {
	    $social = shift(@social_processes);
	    if (not defined($social->[0]) or
		$banned->[0] lt $social->[0] or
		($banned->[0] eq $social->[0] and
		 $NICE_INCR and
		 $banned->[1] < $social->[1])) {
		# No instance of this user with the same nice value.
if ($debug) {# debug
  print_refed_process("freed from coventry", $banned);
}# endebug
		$pid = $banned->[3];
		$current_processes{$pid} = $banned;
		setnice($pid, $banned->[1]);
		unshift(@social_processes, $banned);
	    }
	    elsif (defined($social->[0]) and
			   ($banned->[0] gt $social->[0] or
			    $banned->[1] > $social->[1])) {
		# Keep looking for this user with the same nice value.
		unshift(@banned_processes, $banned);
	    }
	    else {
		# This user is in current processes with the same nice value.
		push(@coventry, $banned);
		if (defined($social->[0])) {
		    unshift(@social_processes, $social);
		}
	    }
	}
    }
}
